[{"lastTimeCrawled":"2024-01-13T15:26:16.807117600","images":[{"src":"https://www.ibm.com/content/dam/connectedassets-adobe-cms/worldwide-content/creative-assets/s-migr/ul/g/83/11/maximo_maintenance1_management.component.xl.ts=1703100087534.png/content/adobe-cms/us/en/topics/artificial-intelligence/_jcr_content/root/leadspace","alt":"Illustration of how AI enables computers to think like humans, interconnected applications and impact on modern life"}],"favicon":"https://www.ibm.com/content/dam/adobe-cms/default-images/favicon.svg","pageTitle":"What is Artificial Intelligence (AI) ? | IBM","rating":474,"pageId":"8e1cee88-e871-4f32-bdc4-25db1ba450e7","pageName":"ibm.com","url":"https://www.ibm.com/topics/artificial-intelligence","content":["While a number of definitions of artificial intelligence (AI) have surfaced over the last few decades, John McCarthy offers the following definition in this 2004 paper (link resides outside ibm.com), \" It is the science and engineering of making intelligent machines, especially intelligent computer programs. It is related to the similar task of using computers to understand human intelligence, but AI does not have to confine itself to methods that are biologically observable.\"","However, decades before this definition, the birth of the artificial intelligence conversation was denoted by Alan Turing's seminal work, \"Computing Machinery and Intelligence\"(link resides outside ibm.com), which was published in 1950. In this paper, Turing, often referred to as the \"father of computer science\", asks the following question, \"Can machines think?\"  From there, he offers a test, now famously known as the \"Turing Test\", where a human interrogator would try to distinguish between a computer and human text response. While this test has undergone much scrutiny since its publish, it remains an important part of the history of AI as well as an ongoing concept within philosophy as it utilizes ideas around linguistics.","Stuart Russell and Peter Norvig then proceeded to publish, Artificial Intelligence: A Modern Approach (link resides outside ibm.com), becoming one of the leading textbooks in the study of AI. In it, they delve into four potential goals or definitions of AI, which differentiates computer systems on the basis of rationality and thinking vs. acting:","Human approach:","Ideal approach:","Alan Turing\u2019s definition would have fallen under the category of \u201csystems that act like humans.\u201d","At its simplest form, artificial intelligence is a field, which combines computer science and robust datasets, to enable problem-solving. It also encompasses sub-fields of machine learning and deep learning, which are frequently mentioned in conjunction with artificial intelligence. These disciplines are comprised of AI algorithms which seek to create expert systems which make predictions or classifications based on input data.","Over the years, artificial intelligence has gone through many cycles of hype, but even to skeptics, the release of OpenAI\u2019s ChatGPT seems to mark a turning point. The last time generative AI loomed this large, the breakthroughs were in computer vision, but now the leap forward is in natural language processing. And it\u2019s not just language: Generative models can also learn the grammar of software code, molecules, natural images, and a variety of other data types.","The applications for this technology are growing every day, and we\u2019re just starting to explore the possibilities. But as the hype around the use of AI in business takes off, conversations around ethics become critically important. To read more on where IBM stands within the conversation around AI ethics, read more here.","Multiply the power of AI for your enterprise with IBM\u2019s next-generation AI and data platform.","Explore the watsonx.ai interactive demo","IBM acquires Manta to complement data and AI governance capabilities","IBM watsonx Orchestrate","IBM watsonx Assistant","Explore Gen AI learning for developers","Weak AI\u2014also called Narrow AI or Artificial Narrow Intelligence (ANI)\u2014is AI trained and focused to perform specific tasks. Weak AI drives most of the AI that surrounds us today. \u2018Narrow\u2019 might be a more accurate descriptor for this type of AI as it is anything but weak; it enables some very robust applications, such as Apple's Siri, Amazon's Alexa, IBM watson, and autonomous vehicles.","Strong AI is made up of Artificial General Intelligence (AGI) and Artificial Super Intelligence (ASI). Artificial general intelligence (AGI), or general AI, is a theoretical form of AI where a machine would have an intelligence equaled to humans; it would have a self-aware consciousness that has the ability to solve problems, learn, and plan for the future. Artificial Super Intelligence (ASI)\u2014also known as superintelligence\u2014would surpass the intelligence and ability of the human brain. While strong AI is still entirely theoretical with no practical examples in use today, that doesn't mean AI researchers aren't also exploring its development. In the meantime, the best examples of ASI might be from science fiction, such as HAL, the superhuman, rogue computer assistant in 2001: A Space Odyssey.","Since deep learning and machine learning tend to be used interchangeably, it\u2019s worth noting the nuances between the two. As mentioned above, both deep learning and machine learning are sub-fields of artificial intelligence, and deep learning is actually a sub-field of machine learning.","Deep learning is actually comprised of neural networks. \u201cDeep\u201d in deep learning refers to a neural network comprised of more than three layers\u2014which would be inclusive of the inputs and the output\u2014can be considered a deep learning algorithm. This is generally represented using the diagram below.","The way in which deep learning and machine learning differ is in how each algorithm learns. Deep learning automates much of the feature extraction piece of the process, eliminating some of the manual human intervention required and enabling the use of larger data sets. You can think of deep learning as \"scalable machine learning\" as Lex Fridman noted in same MIT lecture from above. Classical, or \"non-deep\", machine learning is more dependent on human intervention to learn. Human experts determine the hierarchy of features to understand the differences between data inputs, usually requiring more structured data to learn.","\"Deep\" machine learning can leverage labeled datasets, also known as supervised learning, to inform its algorithm, but it doesn\u2019t necessarily require a labeled dataset. It can ingest unstructured data in its raw form (e.g. text, images), and it can automatically determine the hierarchy of features which distinguish different categories of data from one another. Unlike machine learning, it doesn't require human intervention to process data, allowing us to scale machine learning in more interesting ways."," ","Generative AI refers to deep-learning models that can take raw data \u2014 say, all of Wikipedia or the collected works of Rembrandt \u2014 and \u201clearn\u201d to generate statistically probable outputs when prompted. At a high level, generative models encode a simplified\nrepresentation of their training data and draw from it to create a new work that\u2019s similar,\nbut not identical, to the original data.","Generative models have been used for years in statistics to analyze numerical data. The rise of deep learning, however, made it possible to extend them to images, speech, and other complex data types. Among the first class of models to achieve this cross-over feat were variational autoencoders, or VAEs, introduced in 2013. VAEs were the first deep-learning models to be widely used for generating realistic images and speech.","\u201cVAEs opened the floodgates to deep generative modeling by making models easier to\nscale,\u201d said Akash Srivastava, an expert on generative AI at the MIT-IBM Watson AI Lab.\n\u201cMuch of what we think of today as generative AI started here.\u201d","Early examples of models, like GPT-3, BERT, or DALL-E 2, have shown what\u2019s possible. The future is models that are trained on a broad set of unlabeled data that can be used for different tasks, with minimal fine-tuning. Systems that execute specific tasks in a single domain are giving way to broad AI that learns more generally and works across domains and problems. Foundation models, trained on large, unlabeled datasets and fine-tuned for an array of applications, are driving this shift.","When it comes to generative AI, it is predicted that foundation models will dramatically\naccelerate AI adoption in enterprise. Reducing labeling requirements will make it much\neasier for businesses to dive in, and the highly accurate, efficient AI-driven automation they enable will mean that far more companies will be able to deploy AI in a wider range of mission-critical situations. For IBM, the hope is that the power of foundation models can eventually be brought to every enterprise in a frictionless hybrid-cloud environment.","Explore foundation models in watsonx.ai","There are numerous, real-world applications of AI systems today. Below are some of the most common use cases:","The idea of 'a machine that thinks' dates back to ancient Greece. But since the advent of electronic computing (and relative to some of the topics discussed in this article) important events and milestones in the evolution of artificial intelligence include the following:"," ","Put AI to work in your business with IBM\u2019s industry-leading AI expertise and portfolio of solutions at your side.","Reinvent critical workflows and operations by adding AI to maximize experiences, decision-making and business value.","AI is changing the game for cybersecurity, analyzing massive quantities of risk data to speed response times and augment under-resourced security operations.","Discover fresh insights into the opportunities, challenges and lessons learned from infusing AI into businesses.","Access our full catalog of over 100 online courses by purchasing an individual or multi-user digital learning subscription today allowing you to expand your skills across a range of our products at one low price.","IBM again recognized as a Leader in the 2023 Gartner® Magic Quadrant™ for Enterprise Conversational AI.","IBM has been a leader in advancing AI-driven technologies for enterprises and has pioneered the future of machine learning systems for multiple industries. Learn how IBM watson gives enterprises the AI tools they need to transform their business systems and workflows, while significantly improving automation and efficiency. "]},{"lastTimeCrawled":"2024-01-13T15:26:20.215073","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"GeeksforGeeks | A computer science portal for geeks","rating":316,"pageId":"1fa20e0e-a85c-4ebd-bd81-22a80ac04336","pageName":"GeeksforGeeks | A computer science portal for geeks","url":"https://www.geeksforgeeks.org/","content":[]},{"lastTimeCrawled":"2024-01-13T15:26:20.329026100","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Complete Guide to Arrays Data Structure - GeeksforGeeks","rating":300,"pageId":"5044ee3a-2b5d-46b9-a033-8a67044aad7b","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/complete-guide-to-arrays-data-structure/?ref=outind","content":["Overview","Chapters","Reviews","FAQ\u2019s"]},{"lastTimeCrawled":"2024-01-13T15:26:21.011548600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Matrix or Grid | Multi-Dimensional Array Tutorial - GeeksforGeeks","rating":374,"pageId":"ef54135f-4853-4b65-a884-e69d5990b953","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-matrix-or-grid-data-structure-and-algorithms-tutorial/?ref=outind","content":["A matrix is a two-dimensional array that consists of rows and columns. It is an arrangement of elements in horizontal or vertical lines of entries.","Introduction to Matrix or Grid \u2013 Data Structure and Algorithms Tutorials","The syntax of declaring a Matrix or two-dimensional array is very much similar to that of a one-dimensional array, given as follows.","However, It produces a data structure that looks like the following:","Representation of matrix","As you can see from the above image, the elements are organized in rows and columns. As shown in the above image the cell x[0][0] is the first element of the first row and first column. The value in the first square bracket represents the row number and the value inside the second square bracket represents the column number. (i.e, x[row][column]).","There are two methods to initialize two-dimensional arrays.","Method 1","int arr[4][3]={1, 2, 3, 4, 5, 6, 20, 80, 90, 100, 110, 120};","Method 2","int arr[4][3]={{1, 2, 3}, {4, 5, 6}, {20, 80, 90}, {100, 110, 120}};","Here are two methods of initialization of an element during declaration. Here, the second method is preferred because the second method is more readable and understandable so that you can visualize that arr[][] comprises four rows and three columns.","Like one-dimensional arrays, matrices can be accessed randomly by using their indices to access the individual elements. A cell has two indices, one for its row number, and the other for its column number. We can use X[i][j] to access the element which is at the ith row and jth column of the matrix.","Matrix","The syntax for access element from the matrix which is at the ith row and jth column:","Printing elements of a matrix or two-dimensional array can be done using two \u201cfor\u201d loops.","Given a matrix mat[][] of size N x M, where every row and column is sorted in increasing order, and a number X is given. The task is to find whether element X is present in the matrix or not.","Examples:","Input : mat[][] = { {1, 5, 9},                    {14, 20, 21},                    {30, 34, 43} }       x = 14Output : YES","Input : mat[][] = { {1, 5, 9, 11},                    {14, 20, 21, 26},                    {30, 34, 43, 50} }       x = 42Output : NO","Solution:","There are a lot of ways to solve this problem but let\u2019s discuss the idea of a very naive or brute-force approach here.","A Simple Solution is to one by one compare x with every element of the matrix. If matches, then return true. If we reach the end then return false. The time complexity of this solution is O(n x m).","Below is the implementation of the above idea:","Time Complexity: O(M*N), where M and N are the numbers of rows and columns respectively.Auxiliary Space: O(1)","Given a 2D square matrix, print the Principal and Secondary diagonals.","Examples :","Input: 1 2 3 44 3 2 17 8 9 66 5 4 3Output:Principal Diagonal: 1, 3, 9, 3Secondary Diagonal: 4, 2, 8, 6","Input:1 1 11 1 11 1 1Output:Principal Diagonal: 1, 1, 1Secondary Diagonal: 1, 1, 1","Solution:","The primary diagonal is formed by the elements A00, A11, A22, A33.Condition for Principal Diagonal: The row-column condition is row = column.","The secondary diagonal is formed by the elements A03, A12, A21, A30. Condition for Secondary Diagonal: The row-column condition is row = numberOfRows \u2013 column -1.","Time Complexity: O(n2), As there is a nested loop involved so the time complexity is squared.Auxiliary Space: O(1).  ","Given a n x n matrix. The problem is to sort the given matrix in strict order. Here strict order means that the matrix is sorted in a way such that all elements in a row are sorted in increasing order and for row \u2018i\u2019, where 1 <= i <= n-1, the first element of row \u2018i\u2019 is greater than or equal to the last element of row \u2018i-1\u2019.","Examples:","Input : mat[][] = { {5, 4, 7},                          {1, 3, 8},                         {2, 9, 6} }Output : 1 2 3             4 5 6             7 8 9","Solution: ","The idea to solve this proble is Create a temp[] array of size n^2. Starting with the first row one by one copy the elements of the given matrix into temp[]. Sort temp[]. Now one by one copy the elements of temp[] back to the given matrix.","Below is the implementation:","Time Complexity: O(n2log2n). Auxiliary Space: O(n2), since n * n extra space has been taken.","Given a square matrix, the task is that turn it by 180 degrees in an anti-clockwise direction without using any extra space.","Examples :","Input :  1  2  3        4  5  6        7  8  9Output : 9 8 7         6 5 4         3 2 1","Input :  1 2 3 4         5 6 7 8         9 0 1 2         3 4 5 6 Output : 6 5 4 3         2 1 0 9         8 7 6 5         4 3 2 1","Solution:","There are four steps that are required to solve this problem:1- Find the transpose of a matrix. 2- Reverse columns of the transpose. 3- Find the transpose of a matrix. 4- Reverse columns of the transpose","Illustration:","Let the given matrix be1  2  3  45  6  7  89  10 11 1213 14 15 16","First we find transpose.1 5 9 132 6 10 143 7 11 154 8 12 16","Then we reverse elements of every column.4 8 12 163 7 11 152 6 10 141 5  9 13","then transpose again 4 3 2 1 8 7 6 5 12 11 10 916 15 14 13","Then we reverse elements of every column again16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1","Below is the implementation:","Time complexity: O(R*C) Auxiliary Space: O(1)","Given a matrix mat[][] having n rows and m columns. We need to find unique elements in the matrix i.e, those elements not repeated in the matrix or those whose frequency is 1.","Examples:","Input :  20  15  30  2        2   3   5   30        6   7   6   8Output : 3  20  5  7  8  15","Input :  1  2  3          5  6  2        1  3  5        6  2  2Output : No unique element in the matrix","Solution:","The idea is to use hashing and traverse through all the elements of the matrix, If an element is present in the dictionary, then increment its count. Otherwise insert an element with value = 1. ","Below is the implementation:","Time Complexity: O(m*n) where m is the number of rows & n is the number of columns.Auxiliary Space: O(max(matrix)). ","Related Article:"]},{"lastTimeCrawled":"2024-01-13T15:26:21.614991700","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Complete Guide to String Data Structure - GeeksforGeeks","rating":265,"pageId":"9bab02c9-2188-4bfb-8721-6449bf8b1684","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/complete-guide-to-string-data-structure/?ref=outind","content":["Overview","Chapters","Reviews","FAQ\u2019s","10","Chapters","1","Quizzes","78","Articles","64","Problems","Discover a smoother learning journey through our  effortless roadmap","8 articles","What is String?","Basic String Operations with Implementation","Iterate over characters of a string in C++","Iterate Over the Characters of a String in Java","Iterate over characters of a string in Python","Storage for Strings in C","Storage of String in Java","Applications, Advantages and Disadvantages of String","18 articles","Get a Substring in  C","Number of substrings of one string present in other","Find the count of palindromic sub-string of a string in its sorted form","Check if a string contains a palindromic sub-string of even length","Check if the given string is K-periodic","Longest sub string of 0's  in a binary string which is repeated K times","Find the longest substring with k unique characters in a given string","Shortest Palindromic Substring","Count of K-size substrings having palindromic permutations","Maximize partitions such that no two substrings have any common character","Count of substrings having all distinct characters","Smallest String consisting of a String S exactly K times as a Substring","Check if a String contains Anagrams of length K which does not contain the character X","Check if a Palindromic String can be formed by concatenating Substrings of two given Strings","Minimum size substring to be removed to make a given string palindromic","Count ways to split a Binary String into three substrings having equal count of zeros","Count of substrings of a string containing another given string as a substring","Longest substring where all the characters appear at least K times | Set 3","13 articles","Print all subsequences of a string","Check if two same sub-sequences exist in a string or not","Minimum number of palindromic subsequences to be removed to empty a binary string","Find largest word in dictionary by deleting some characters of given string","Longest Common Anagram Subsequence","Find the lexicographically largest palindromic Subsequence of a String","Maximum number of removals of given subsequence from a string","Longest subsequence with at least one character appearing in every string","Distinct strings such that they contains given strings as sub-sequences","Smallest Palindromic Subsequence of Even Length in Range [L, R]","Minimum number of subsequences required to convert one string to another","Longest Palindromic Subsequence of two distinct characters","Longest subsequence with different adjacent characters","2 articles","Check if a string is substring of another","Print all occurrences of a string as a substring in another string","5 articles","Naive algorithm for Pattern Searching","Rabin-Karp Algorithm for Pattern Searching","KMP Algorithm for Pattern Searching","Z algorithm (Linear time pattern searching Algorithm)","Suffix Array | Set 1 (Introduction)","4 articles","Find all the patterns of \"1(0+)1\" in a given string (General Approach)","Minimum number of times A has to be repeated such that B is a substring of it","Anagram Substring Search (Or Search for all permutations)","Longest prefix which is also suffix","14 articles","Reverse a String","Reverse words in a given string","Program to count occurrence of a given character in a string","Convert  characters of a string to opposite case","Program to count vowels in a string (Iterative and Recursive)","Check if a number is Palindrome","Remove duplicates from a given string","Count words in a given string","Check if a string is substring of another","Check whether two Strings are anagram of each other","Remove minimum number of characters so that two strings become anagram","Minimum Number of Manipulations required to make two Strings Anagram Without Deletion of Character","Capitalize the first and last character of each word in a string","Check if given strings are rotations of each other or not","8 articles","Print all palindrome permutations of a string","Sum of two large numbers","Multiply Large Numbers represented as Strings","Length of the longest valid substring","Length of the longest substring without repeating characters","Find the longest substring with k unique characters in a given string","Smallest window that contains all characters of string itself","Minimum rotations required to get the same string","5 articles","Palindrome Substring Queries","Minimum number of bracket reversals needed to make an expression balanced","Number of distinct words of size N with at most K contiguous vowels","Longest substring whose characters can be rearranged to form a Palindrome","Find all distinct palindromic sub-strings of a given string","1 articles","String Data Structure Quiz for Beginners","The Complete Guide to Strings is a comprehensive resource that covers everything you need to know about working with string data in programming. From understanding what strings are to advanced string manipulation techniques, this guide offers insights into their importance across various applications, such as text processing, user input, and data analysis. Whether you're a beginner or an experienced developer, this guide will help you master the art of handling strings effectively.","While learning about String Data Structures in this Complete Guide on String, you will come across some common terms that will be used multiple times. Some of these terms are:","The String data structure is essential for handling text-based data in the field of programming, user input, file content, and more. The vast availability of String manipulation functions, such as joining, searching, formatting, etc, in every programming language makes it one of the most used Data Structure. Some of imporatant field where String Data Structure is used are text processing, user interfaces, data analysis, networking, and Web Development.","Abhishek sirohi","The roadmap provided here is a very good start to understanding the basics and covers all types of DSA concepts. I am completely satisfied with this roadmap.","Ayan Prakash","There is a clear explanation of all topics covered in this roadmap, and the practice problems that are provided are very helpful to help implement the concepts learned. Kudos to GeeksforGeeks!!!","Nupur Bisht","There is no doubt that GeeksforGeeks has covered all the important topics in the most effective way. As a result of this roadmap, I am placed in very good company.","Tanisha Singh","In my opinion, the roadmap of GFG is very well structured. It's awesome how they arranged the readings. I found it to be very helpful.","How can I start this course?","You just need to click on the button that says START YOUR JOURNEY, and that's it. You will be taken to your first chapter.","Is this a language-specific course?","No. Majority topics in the course include implementations in popular programming languages like C, C++, Java, Python, C#, and Javascript.","Does the course include programming questions?","Yes, the course focuses on DS & Algo with a mix of theoretical topics and programming questions.","Can I learn DSA live?","Yes, we do have LIVE batched for DSA. You may call us on our toll-free number: +91-7838223507 or Drop us an email at courses@geeksforgeeks.org for any queries."]},{"lastTimeCrawled":"2024-01-13T15:26:21.781926600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Singly Linked List - GeeksforGeeks","rating":300,"pageId":"aab5dcbe-1af8-46a8-bf0b-085ac5952e13","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/data-structures/linked-list/singly-linked-list/?ref=outind","content":["Learn more about Singly Linked List in DSA Self Paced Course\nPractice Problems on Singly Linked List","A singly linked list is a linear data structure in which the elements are not stored in contiguous memory locations and each element is connected only to its next element using a pointer.","Singly Linked List","Topics:","Introduction:","Basic Operations:","Some Problems on Singly Linked List:","Quick Links :"]},{"lastTimeCrawled":"2024-01-13T15:26:22.124073100","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Insertion in a Doubly Linked List - GeeksforGeeks","rating":361,"pageId":"2d97005c-47e9-4b89-99d8-1bf17f0130bf","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/doubly-linked-list/?ref=outind","content":["Inserting a new node in a doubly linked list is very similar to inserting new node in linked list. There is a little extra work required to maintain the link of the previous node. A node can be inserted in a Doubly Linked List in four ways:","The new node is always added before the head of the given Linked List. The task can be performed by using the following 5 steps:","Illustration:","See the below illustration where E is being inserted at the beginning of the doubly linked list.","Below is the implementation of the 5 steps to insert a node at the front of the linked list:","Time Complexity: O(1)Auxiliary Space: O(1)","It is further classified into the following two parts:","We are given a pointer to a node as prev_node, and the new node is inserted after the given node. This can be done using the following 6 steps:","Illustration:","See the below illustration where \u2018E\u2018 is being inserted after \u2018B\u2018.","Below is the implementation of the 7 steps to insert a node after a given node in the linked list:","Time Complexity: O(1)Auxiliary Space: O(1)","Let the pointer to this given node be next_node. This can be done using the following 6 steps. ","Illustration:","See the below illustration where \u2018B\u2018 is being inserted before \u2018C\u2018.","Below is the implementation of the above approach.","Time Complexity: O(1)Auxiliary Space: O(1)","The new node is always added after the last node of the given Linked List. This can be done using the following 7 steps:","Illustration:","See the below illustration where \u2018D\u2018 is inserted at the end of the linked list.","Below is the implementation of the 7 steps to insert a node at the end of the linked list:","Time Complexity: O(n)Auxiliary Space: O(1)","Related Articles:"," "]},{"lastTimeCrawled":"2024-01-13T15:26:22.476929200","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Circular Linked List - GeeksforGeeks","rating":316,"pageId":"5d36fd9a-39f3-49e9-823f-030db95538f4","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/circular-linked-list/?ref=outind","content":["The circular linked list is a linked list where all nodes are connected to form a circle. In a circular linked list, the first node and the last node are connected to each other which forms a circle. There is no NULL at the end."," ","There are generally two types of circular linked lists:","Representation of Circular singly linked list","Representation of circular doubly linked list","Note: We will be using the singly circular linked list to represent the working of the circular linked list.","Circular linked lists are similar to single Linked Lists with the exception of connecting the last node to the first node.","Node representation of a Circular Linked List:","Example of Circular singly linked list:","Example of  circular linked list","The above  Circular singly linked list can be represented as:","Explanation: In the above program one, two, and three are the node with values 3, 5, and 9 respectively which are connected in a circular manner as:","We can do some operations on the circular linked list similar to the singly linked list which are:","A node can be added in three ways:","1) Insertion at the beginning of the list: To insert a node at the beginning of the list, follow these steps: ","Circular linked list before insertion","And then, ","Circular linked list after insertion","2) Insertion at the end of the list: To insert a node at the end of the list, follow these steps: ","Before insertion,","Circular linked list before insertion of node at the end","After insertion,","Circular linked list after insertion of node at the end","3) Insertion in between the nodes: To insert a node in between the two nodes, follow these steps: ","Suppose 12 needs to be inserted after the node has the value 10,","Circular linked list before insertion","After searching and insertion,","Circular linked list after  insertion","1) Delete the node only if it is the only node in the circular linked list:","2) Deletion of the last node:","3) Delete any node from the circular linked list: We will be given a node and our task is to delete that node from the circular linked list.","Algorithm:Case 1: List is empty. ","Case 2:List is not empty  ","Below is the implementation for the above approach:","Time Complexity: O(N), Worst case occurs when the element to be deleted is the last element and we need to move through the whole list.Auxiliary Space: O(1), As constant extra space is used.","Next Posts: Circular Linked List | Set 2 (Traversal) Circular Singly Linked List | Insertion Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem"]},{"lastTimeCrawled":"2024-01-13T15:26:22.786369500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Insertion in Doubly Circular Linked List - GeeksforGeeks","rating":332,"pageId":"d89a65f1-4206-44e7-b313-b4b4b8325f29","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/doubly-circular-linked-list-set-1-introduction-and-insertion/?ref=outind","content":["Circular Doubly Linked List has properties of both doubly linked list and circular linked list in which two consecutive elements are linked or connected by the previous and next pointer and the last node points to the first node by the next pointer and also the first node points to the last node by the previous pointer.","Following is the representation of a Circular doubly linked list node in C/C++: "," ","Circular Doubly Linked LIst","A node(Say N) is inserted with data = 5. So, the previous pointer of N points to N and the next pointer of N also points to N. But now start pointer points to the first node of the list.","Insertion in an empty list","A node(Say M) is inserted with data = 7, so the previous pointer of M points to the last node, the next pointer of M points to the first node and the last node\u2019s next pointer points to this M node, and first node\u2019s previous pointer points to this M node.","Insertion at the end of list","Below is the implementation of the above operations:","To insert a node at the beginning of the list, create a node(Say T) with data = 5, T next pointer points to the first node of the list, T previous pointer points to the last node of the list, last node\u2019s next pointer points to this T node, first node\u2019s previous pointer also points this T node and at last don\u2019t forget to shift \u2018Start\u2019 pointer to this T node.","Insertion at the beginning of the list","Below is the implementation of the above operation:","To insert a node in between the list, two data values are required one after which new node will be inserted and another is the data of the new node.","Insertion in between other nodes","Below is the implementation of the above operation:","Following is a complete program that uses all of the above methods to create a circular doubly linked list.  ","Time Complexity: O(N)Auxiliary Space: O(1), As constant extra space is used.","This article is contributed by Akash Gupta.","A"]},{"lastTimeCrawled":"2024-01-13T15:26:23.263369200","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Linked List - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":316,"pageId":"00ee535b-3709-436f-8fed-1cf284812cb7","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-linked-list-data-structure-and-algorithm-tutorial/?ref=outind","content":["A Linked List is a linear data structure which looks like a chain of nodes, where each node is a different element. Unlike Arrays, Linked List elements are not stored at a contiguous location. ","It is basically chains of nodes, each node contains information such as data and a pointer to the next node in the chain. In the linked list there is a head pointer, which points to the first element of the linked list, and if the list is empty then it simply points to null or nothing.","Linked List Tutorial","Here are a few advantages of a linked list that is listed below, it will help you understand why it is necessary to know.","There are mainly three types of linked lists:","Traversal of items can be done in the forward direction only due to the linking of every node to its next node.","Singly Linked List","The following operations are performed on a Single Linked List","Traversal of items can be done in both forward and backward directions as every node contains an additional prev pointer that points to the previous node.","Doubly linked list","A Node Creation:","In a double-linked list, we perform the following operations\u2026","A circular linked list is a type of linked list in which the first and the last nodes are also connected to each other to form a circle, there is no NULL at the end. ","Circular Linked List","The following operations are performed on a Circular Linked List","Linked List vs. Array","Here are some of the applications of a linked list:","18","Merge Sort for Linked Lists","view","solve","Linked list are most commonly used to handle dynamic data elements. Linked list consists of nodes and a node consists of two fields one for storing data and other for keeping the reference of next node.","A linked list can be assumed as a garland that is made up of flowers. Similarly, a linked list is made up of nodes. Every flower in this particular garland is referred to as a node. In addition, each node points to the next node in this list, and it contains data (in this case, the type of flower).","There are some important advantages to using linked lists over other linear data structures. This is unlike arrays, as they are resizable at runtime. Additionally, they can be easily inserted and deleted.","The linked list is a linear data structure that stores data in nodes. these nodes hold both the data and a reference to the next node in the list. Linked are very efficient at adding and removing nodes because of their simple structure.","There are some following differences between them:","Following are the reason that linked lists are preferred over array","Following are some difference between single and double linked list.","There are some advantages and disadvantages to both arrays and linked lists when it comes to storing linear data of similar types.","Following are some limitations of the linked list:","If any element is inserted/ deleted from the array, all the other elements after it will be shifted in memory this takes a lot of time whereas manipulation in Linked List is faster because we just need to manipulate the addresses of nodes, so no bit shifting is required in memory, and it will not take that much of time.","There are many advantages of the linked list compared to array, despite the fact that they solve the similar problem to arrays, we have also discussed the advantage, disadvantages, and its application, and we concluded the fact that we can use a linked list if we need the dynamic size of storage and list are good for adding and removing items quickly or for tasks that require sequence but are not suitable for querying or search elements in a large collection of data.","So, it becomes important that we should always keep in mind the positive and negative aspects of a data structure and how they relate to the problem you are trying to solve.","Related articles:"]},{"lastTimeCrawled":"2024-01-13T15:26:23.706533","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Stack - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":300,"pageId":"7e249cf8-554a-4f61-802f-80d65f0abc58","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-stack-data-structure-and-algorithm-tutorials/?ref=outind","content":["A stack is a linear data structure in which the insertion of a new element and removal of an existing element takes place at the same end represented as the top of the stack.","To implement the stack, it is required to maintain the pointer to the top of the stack, which is the last element to be inserted because we can access the elements only on the top of the stack.","LIFO( Last In First Out ):","This strategy states that the element that is inserted last will come out first. You can take a pile of plates kept on top of each other as a real-life example. The plate which we put last is on the top and since we remove the plate that is at the top, we can say that the plate that was put last comes out first.","In order to make manipulations in a stack, there are certain operations provided to us.","Stack","Adds an item to the stack. If the stack is full, then it is said to be an Overflow condition.","Algorithm for push:","Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.","Algorithm for pop:","Returns the top element of the stack.","Algorithm for Top:","Returns true if the stack is empty, else false.","Algorithm for isEmpty:","There are many real-life examples of a stack. Consider the simple example of plates stacked over one another in a canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow the LIFO/FILO order.","In addition to these two main types, there are several other variations of Stacks, including:","A stack can be implemented using an array or a linked list. In an array-based implementation, the push operation is implemented by incrementing the index of the top element and storing the new element at that index. The pop operation is implemented by decrementing the index of the top element and returning the value stored at that index. In a linked list-based implementation, the push operation is implemented by creating a new node with the new element and setting the next pointer of the current top node to the new node. The pop operation is implemented by setting the next pointer of the current top node to the next node and returning the value of the current top node.","Stacks are commonly used in computer science for a variety of applications, including the evaluation of expressions, function calls, and memory management. In the evaluation of expressions, a stack can be used to store operands and operators as they are processed. In function calls, a stack can be used to keep track of the order in which functions are called and to return control to the correct function when a function returns. In memory management, a stack can be used to store the values of the program counter and the values of the registers in a computer program, allowing the program to return to the previous state when a function returns.","In conclusion, a Stack is a linear data structure that operates on the LIFO principle and can be implemented using an array or a linked list. The basic operations that can be performed on a stack include push, pop, and peek, and stacks are commonly used in computer science for a variety of applications, including the evaluation of expressions, function calls, and memory management.There are two ways to implement a stack \u2013","Related Articles:"]},{"lastTimeCrawled":"2024-01-13T15:26:24.168304300","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Queue - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":332,"pageId":"71755079-5ea3-42f4-b5ff-4a449cd0e7e9","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials/?ref=outind","content":["A queue is a linear data structure that is open at both ends and the operations are performed in First In First Out (FIFO) order.","We define a queue to be a list in which all additions to the list are made at one end, and all deletions from the list are made at the other end.  The element which is first pushed into the order, the delete operation is first performed on that.","FIFO property of queue","Like stacks, Queues can also be represented in an array: In this representation, the Queue is implemented using the array. Variables used in this case are","Array representation of queue:","A queue can also be represented using following entities:","There are different types of queues:","To learn more about different types of queues, read the article on \u201cTypes of Queues\u201c.","Some of the basic operations for Queue in Data Structure are:","There are a few supporting operations (auxiliary operations):","Enqueue() operation in Queue adds (or stores) an element to the end of the queue.The following steps should be taken to enqueue (insert) data into a queue:","Enqueue representation","Implementation of Enqueue:","Removes (or access) the first element from the queue.The following steps are taken to perform the dequeue operation:","Dequeue operation","Implementation of dequeue:","This operation returns the element at the front end without removing it.","This operation returns the element at the rear end without removing it.","This operation returns a boolean value that indicates whether the queue is empty or not.","This operation returns a boolean value that indicates whether the queue is full or not.","Queue can be implemented using following data structures:","We have discussed the Structure implementation of Queue below:","Time complexity: All the operations have O(1) time complexity.Auxiliary Space: O(N) ","Application of queue is common. In a computer system, there may be queues of tasks waiting for the printer, for access to disk storage, or even in a time-sharing system, for use of the CPU. Within a single program, there may be multiple requests to be kept in a queue, or one task may create other tasks, which must be done in turn by keeping them in a queue.","Priority queues can be implemented using a variety of data structures, including linked lists, arrays, binary search trees, and heaps. Priority queues are best implemented using the heap data structure.","In addition to making your data persistent, queues reduce errors that occur when different parts of your system are down.","In a double-ended queue, elements can be inserted and removed at both ends.","If you want things to come out in the order you put them in, use a queue. Stacks are useful when you want to reorder things after putting them in. ","Related articles:"]},{"lastTimeCrawled":"2024-01-13T15:26:24.491080600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Generic Trees (N-ary Trees) - GeeksforGeeks","rating":283,"pageId":"6dca9086-65bd-482e-a691-842c329d822b","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/generic-treesn-array-trees/?ref=outind","content":["Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children(duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes. Every node stores address of its children and the very first node\u2019s address will be stored in a separate pointer called root.","The Generic trees are the N-ary trees which have the following properties: ","            1. Many children at every node.","            2. The number of nodes for each node is not known in advance.","Example:  ","Generic Tree","To represent the above tree, we have to consider the worst case, that is the node with maximum children (in above example, 6 children) and allocate that many pointers for each node.The node representation based on this method can be written as: ","Disadvantages of the above representation are: ","Simple Approach: ","For storing the address of children in a node we can use an array or linked list. But we will face some issues with both of them.","Better Approach:","We can use Dynamic Arrays for storing the address of children. We can randomly access any child\u2019s address and the size of the vector is also not fixed.","First child / Next sibling representation"," In the first child/next sibling representation, the steps taken are: ","At each node-link the children of the same parent(siblings) from left to right.","Since we have a link between children, we do not need extra links from parents to all the children. This representation allows us to traverse all the elements by starting at the first child of the parent. ","FIRST CHILD/NEXT SIBLING REPRESENTATION","The node declaration for first child / next sibling representation can be written as:  ","Advantages: ","Height of generic tree from parent array Generic tree \u2013 level order traversal","S"]},{"lastTimeCrawled":"2024-01-13T15:26:25.034523500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Binary Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":412,"pageId":"b2fed075-d8e4-44ff-b9ef-c4e10ba95259","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-binary-tree-data-structure-and-algorithm-tutorials/?ref=outind","content":["A binary tree is a tree data structure in which each node can have at most two children, which are referred to as the left child and the right child. ","The topmost node in a binary tree is called the root, and the bottom-most nodes are called leaves. A binary tree can be visualized as a hierarchical structure with the root at the top and the leaves at the bottom.","Binary trees have many applications in computer science, including data storage and retrieval, expression evaluation, network routing, and game AI. They can also be used to implement various algorithms such as searching, sorting, and graph algorithms.","Each node in the tree contains the following:","Binary Tree","In C, we can represent a tree node using structures. In other languages, we can use classes as part of their OOP feature. Below is an example of a tree node with integer data.","Tree Traversal algorithms can be classified broadly into two categories:","Let us traverse the following tree with all four traversal methods:","Binary Tree","Pre-order Traversal of the above tree: 1-2-4-5-3-6-7In-order Traversal of the above tree: 4-2-5-1-6-3-7Post-order Traversal of the above tree: 4-5-2-6-7-3-1Level-order Traversal of the above tree: 1-2-3-4-5-6-7","Let us create a simple tree with 4 nodes. The created tree would be as follows. ","Binary Tree","Below is the Implementation of the binary tree:","Tree is a hierarchical data structure. Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children."]},{"lastTimeCrawled":"2024-01-13T15:26:25.493144","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Binary Search Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":387,"pageId":"49f37725-2ebc-4a1a-9bcc-aa3bba49db96","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-binary-search-tree-data-structure-and-algorithm-tutorials/?ref=outind","content":["A Binary Search Tree (BST) is a special type of binary tree in which the left child of a node has a value less than the node\u2019s value and the right child has a value greater than the node\u2019s value. This property is called the BST property and it makes it possible to efficiently search, insert, and delete elements in the tree.","The root of a BST is the node that has the smallest value in the left subtree and the largest value in the right subtree. Each left subtree is a BST with nodes that have smaller values than the root and each right subtree is a BST with nodes that have larger values than the root.","Binary Search Tree is a node-based binary tree data structure that has the following properties: ","Handling approach for Duplicate values in the Binary Search tree:","Below are the various operations that can be performed on a BST:","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Different scenarios for deleting the node:","Time Complexity: O(log N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(log N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ","Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) "]},{"lastTimeCrawled":"2024-01-13T15:26:25.730585400","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"AVL Tree Data Structure - GeeksforGeeks","rating":283,"pageId":"ec70a5f7-8ed6-4a14-9e77-8938b388e0e5","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-avl-tree/?ref=outind","content":["An AVL tree defined as a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees for any node cannot be more than one.","The difference between the heights of the left subtree and the right subtree for any node is known as the balance factor of the node.","The AVL tree is named after its inventors, Georgy Adelson-Velsky and Evgenii Landis, who published it in their 1962 paper \u201cAn algorithm for the organization of information\u201d.","AVL tree","The above tree is AVL because the differences between the heights of left and right subtrees for every node are less than or equal to 1.","An AVL tree may rotate in one of the following four ways to keep itself balanced:","Left Rotation:","When a node is added into the right subtree of the right subtree, if the tree gets out of balance, we do a single left rotation.","Left-Rotation in AVL tree","Right Rotation:","If a node is added to the left subtree of the left subtree, the AVL tree may get out of balance, we do a single right rotation.","Right-Rotation in AVL Tree","Left-Right Rotation:","A left-right rotation is a combination in which first left rotation takes place after that right rotation executes.","Left-Right Rotation in AVL tree","Right-Left Rotation:","A right-left rotation is a combination in which first right rotation takes place after that left rotation executes.","Right-Left Rotation in AVL tree","Related Articles:"]},{"lastTimeCrawled":"2024-01-13T15:26:26.359024900","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction of B-Tree - GeeksforGeeks","rating":300,"pageId":"080a7d49-f396-426a-8743-d93fee39383e","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-of-b-tree-2/?ref=outind","content":["The limitations of traditional binary search trees can be frustrating. Meet the B-Tree, the multi-talented data structure that can handle massive amounts of data with ease. When it comes to storing and searching large amounts of data, traditional binary search trees can become impractical due to their poor performance and high memory usage. B-Trees, also known as B-Tree or Balanced Tree, are a type of self-balancing tree that was specifically designed to overcome these limitations.","Unlike traditional binary search trees, B-Trees are characterized by the large number of keys that they can store in a single node, which is why they are also known as \u201clarge key\u201d trees. Each node in a B-Tree can contain multiple keys, which allows the tree to have a larger branching factor and thus a shallower height. This shallow height leads to less disk I/O, which results in faster search and insertion operations. B-Trees are particularly well suited for storage systems that have slow, bulky data access such as hard drives, flash memory, and CD-ROMs.","B-Trees maintains balance by ensuring that each node has a minimum number of keys, so the tree is always balanced. This balance guarantees that the time complexity for operations such as insertion, deletion, and searching is always O(log n), regardless of the initial shape of the tree.","Note: \u201cn\u201d is the total number of elements in the B-tree","Following is an example of a B-Tree of minimum order 5 Note: that in practical B-Trees, the value of the minimum order is much more than 5.  ","We can see in the above diagram that all the leaf nodes are at the same level and all non-leafs have no empty sub-tree and have keys one less than the number of their children.","Traversal is also similar to Inorder traversal of Binary Tree. We start from the leftmost child, recursively print the leftmost child, then repeat the same process for the remaining children and keys. In the end, recursively print the rightmost child. ","Search is similar to the search in Binary Search Tree. Let the key to be searched is k. ","Searching a B-Tree is similar to searching a binary tree. The algorithm is similar and goes with recursion. At each level, the search is optimized as if the key value is not present in the range of the parent then the key is present in another branch. As these values limit the search they are also known as limiting values or separation values. If we reach a leaf node and don\u2019t find the desired key then it will display NULL.","Examples: ","Input: Search 120 in the given B-Tree.  "," Solution:  "," "," ","In this example, we can see that our search was reduced by just limiting the chances where the key containing the value could be present. Similarly if within the above example we\u2019ve to look for 180, then the control will stop at step 2 because the program will find that the key 180 is present within the current node. And similarly, if it\u2019s to seek out 90 then as 90 < 100 so it\u2019ll go to the left subtree automatically, and therefore the control flow will go similarly as shown within the above example.","Below is the implementation of the above approach:","Note: The above code doesn\u2019t contain the driver program. We will be covering the complete program in our next post on B-Tree Insertion.","There are two conventions to define a B-Tree, one is to define by minimum degree, second is to define by order. We have followed the minimum degree convention and will be following the same in coming posts on B-Tree. The variable names used in the above program are also kept the same","Insertion and Deletion:B-Tree Insertion B-Tree Deletion"]},{"lastTimeCrawled":"2024-01-13T15:26:26.967074500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction of B+ Tree - GeeksforGeeks","rating":265,"pageId":"97a18111-ac3d-4d9b-b527-3095408ae5d6","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-of-b-tree/?ref=outind","content":["B + Tree is a variation of the B-tree data structure. In a B + tree, data pointers are stored only at the leaf nodes of the tree. In a B+ tree structure of a leaf node differs from the structure of internal nodes. The leaf nodes have an entry for every value of the search field, along with a data pointer to the record (or to the block that contains this record). The leaf nodes of the B+ tree are linked together to provide ordered access to the search field to the records. Internal nodes of a B+ tree are used to guide the search. Some search field values from the leaf nodes are repeated in the internal nodes of the B+ tree.","Some differences between B+ Tree and B Tree are stated below.","Parameters","B+ Tree"," B Tree","Structure","Separate leaf nodes for data storage and internal nodes for indexing","Nodes store both keys and data values","Leaf Nodes","Leaf nodes form a linked list for efficient range-based queries","Leaf nodes do not form a linked list","Order","Higher order (more keys)"," Lower order (fewer keys)","Key Duplication","Typically allows key duplication in leaf nodes","Usually does not allow key duplication","Disk Access","Better disk access due to sequential reads in a linked list structure","More disk I/O due to non-sequential reads in internal nodes","Applications","Database systems, file systems, where range queries are common","In-memory data structures, databases, general-purpose use","Performance","Better performance for range queries and bulk data retrieval","Balanced performance for search, insert, and delete operations","Memory Usage","Requires more memory for internal nodes","Requires less memory as keys and values are stored in the same node","In order, to implement dynamic multilevel indexing, B-tree and B+ tree are generally employed. The drawback of the B-tree used for indexing, however, is that it stores the data pointer (a pointer to the disk file block containing the key value), corresponding to a particular key value, along with that key value in the node of a B-tree. This technique greatly reduces the number of entries that can be packed into a node of a B-tree, thereby contributing to the increase in the number of levels in the B-tree, hence increasing the search time of a record. B+ tree eliminates the above drawback by storing data pointers only at the leaf nodes of the tree. Thus, the structure of the leaf nodes of a B+ tree is quite different from the structure of the internal nodes of the B tree. It may be noted here that, since data pointers are present only at the leaf nodes, the leaf nodes must necessarily store all the key values along with their corresponding data pointers to the disk file block, in order to access them. ","Moreover, the leaf nodes are linked to providing ordered access to the records. The leaf nodes, therefore form the first level of the index, with the internal nodes forming the other levels of a multilevel index. Some of the key values of the leaf nodes also appear in the internal nodes, to simply act as a medium to control the searching of a record. From the above discussion, it is apparent that a B+ tree, unlike a B-tree, has two orders, \u2018a\u2019 and \u2018b\u2019, one for the internal nodes and the other for the external (or leaf) nodes. ","B+ Trees","B+ Trees contain two types of nodes:","Structure of  Internal Node","Structure of Lead Node","Diagram-II Using the Pnext pointer it is viable to traverse all the leaf nodes, just like a linked list, thereby achieving ordered access to the records stored in the disk. ","Tree Pointer","Searching Record in B+ Trees","Let us suppose we have to find 58 in the B+ Tree. We will start by fetching from the root node then we will move to the leaf node, which might contain a record of 58. In the image given above, we will get 58 between 50 and 70. Therefore, we will we are getting a leaf node in the third leaf node and get 58 there. If we are unable to find that node, we will return that \u2018record not founded\u2019 message.","Insertion in B+ Trees is done via the following steps.","For more, refer to Insertion in a B+ Trees.","Deletion in B+ Trees is just not deletion but it is a combined process of Searching, Deletion, and Balancing. In the last step of the Deletion Process, it is mandatory to balance the B+ Trees, otherwise, it fails in the property of B+ Trees.","For more, refer to Deletion in B+ Trees.","In conclusion, B+ trees are an essential component of contemporary database systems since they significantly improve database performance and make efficient data management possible.","Answer:","B+ Tree is balanced binary search tree that can simply be a B Tree, where data is stored in keys, not key-value pairs.","Answer:","The height of the B+ Trees is mostly balanced and is comparatively lesser than B-Trees.","Answer:","B+ Trees are often used for disk-based storage systems.","S"]},{"lastTimeCrawled":"2024-01-13T15:26:27.528050300","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Red-Black Tree - GeeksforGeeks","rating":245,"pageId":"e3e46cc3-911f-41c7-b557-6855b43bdc4b","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-red-black-tree/?ref=outind","content":["When it comes to searching and sorting data, one of the most fundamental data structures is the binary search tree. However, the performance of a binary search tree is highly dependent on its shape, and in the worst case, it can degenerate into a linear structure with a time complexity of O(n). This is where Red Black Trees come in, they are a type of balanced binary search tree that use a specific set of rules to ensure that the tree is always balanced. This balance guarantees that the time complexity for operations such as insertion, deletion, and searching is always O(log n), regardless of the initial shape of the tree.","Red Black Trees are self-balancing, meaning that the tree adjusts itself automatically after each insertion or deletion operation. It uses a simple but powerful mechanism to maintain balance, by coloring each node in the tree either red or black. ","Red Black Tree-","Red-Black tree is a binary search tree in which every node is colored with either red or black. It is a type of self balancing binary search tree. It has a good efficient worst case running time complexity.","The Red-Black tree satisfies all the properties of binary search tree in addition to that it satisfies following additional properties \u2013","1. Root property: The root is black.","2. External property: Every leaf (Leaf is a NULL child of a node) is black in Red-Black tree.","3. Internal property: The children of a red node are black. Hence possible parent of red node is a black node.","4. Depth property: All the leaves have the same black depth.","5. Path property: Every simple path from root to descendant leaf node contains same number of black nodes. ","The result of all these above-mentioned properties is that the Red-Black tree is roughly balanced.","Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that the height of the tree remains O(log n) after every insertion and deletion, then we can guarantee an upper bound of O(log n) for all these operations. The height of a Red-Black tree is always O(log n) where n is the number of nodes in the tree. ","\u201cn\u201d is the total number of elements in the red-black tree. ","Comparison with AVL Tree:The AVL trees are more balanced compared to Red-Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves frequent insertions and deletions, then Red-Black trees should be preferred. And if the insertions and deletions are less frequent and search is a more frequent operation, then AVL tree should be preferred over the Red-Black Tree.","How does a Red-Black Tree ensure balance?A simple example to understand balancing is, that a chain of 3 nodes is not possible in the Red-Black tree. We can try any combination of colors and see if all of them violate the Red-Black tree property. ","Proper structure of three noded Red-black tree","Black height is the number of black nodes on a path from the root to a leaf. Leaf nodes are also counted black nodes. From the above properties 3 and 4, we can derive, a Red-Black Tree of height h has black-height >= h/2. ","Number of nodes from a node to its farthest descendant leaf is no more than twice as the number of nodes to the nearest descendant leaf.","Every Red Black Tree with n nodes has height <= 2Log2(n+1) This can be proved using the following facts:","From the above points, we can conclude the fact that Red Black Tree with n nodes has a height <= 2Log2(n+1)","As every red-black tree is a special case of a binary tree so the searching algorithm of a red-black tree is similar to that of a binary tree.","Algorithm:","For the program, you can refer it for AVL tree. ","Example: Searching 11 in the following red-black tree.  ","Solution: "," Just follow the blue bubble.","In this post, we introduced Red-Black trees and discussed how balance is ensured. The hard part is to maintain balance when keys are added and removed. We have also seen how to search an element from the red-black tree. We will soon be discussing insertion and deletion operations in coming posts on the Red-Black tree.","1) Is it possible to have all black nodes in a Red-Black tree? 2) Draw a Red-Black Tree that is not an AVL tree structure-wise?","Red-Black Tree Insertion Red-Black Tree Deletion "]},{"lastTimeCrawled":"2024-01-13T15:26:27.933891700","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"2acd59cd-a0ab-4134-a7f1-559d943b7785","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/?ref=outind","content":["A tree data structure is a hierarchical structure that is used to represent and organize data in a way that is easy to navigate and search. It is a collection of nodes that are connected by edges and has a hierarchical relationship between the nodes. ","The topmost node of the tree is called the root, and the nodes below it are called the child nodes. Each node can have multiple child nodes, and these child nodes can also have their own child nodes, forming a recursive structure.","This data structure is a specialized method to organize and store data in the computer to be used more effectively. It consists of a central node, structural nodes, and sub-nodes, which are connected via edges. We can also say that tree data structure has roots, branches, and leaves connected with one another.","Introduction to Tree \u2013 Data Structure and Algorithm Tutorials","A tree consists of a root, and zero or more subtrees T1, T2, \u2026 , Tk such that there is an edge from the root of the tree to the root of each subtree.","Representation of Tree Data Structure","struct Node{   int data;   struct Node *first_child;   struct Node *second_child;   struct Node *third_child;   .   .   .   struct Node *nth_child;};"," ","Here,","To learn more about types of trees, refer to this article.","The data in a tree are not stored in a sequential manner i.e., they are not stored linearly. Instead, they are arranged on multiple levels or we can say it is a hierarchical structure. For this reason, the tree is considered to be a non-linear data structure.","1. One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: ","File System","2. Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays). 3. Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists). 4. Like Linked Lists and unlike Arrays, Trees don\u2019t have an upper limit on the number of nodes as nodes are linked using pointers.","To learn more about the applications of Tree Data Structure, refer to this article.","To learn more about the advantages of Tree Data Structure, refer to this article.","To learn more about the disadvantages of Tree Data Structure, refer to this article."]},{"lastTimeCrawled":"2024-01-13T15:26:28.357853400","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Heap - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"987215f1-007c-48a1-a48b-c89fcd403d54","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-heap-data-structure-and-algorithm-tutorials/?ref=outind","content":["A Heap is a special Tree-based Data Structure in which the tree is a complete binary tree.","Generally, heaps are of two types.","In this heap, the value of the root node must be the greatest among all its child nodes and the same thing must be done for its left and right sub-tree also.","The total number of comparisons required in the max heap is according to the height of the tree. The height of the complete binary tree is always logn; therefore, the time complexity would also be O(logn).","In this heap, the value of the root node must be the smallest among all its child nodes and the same thing must be done for its left and right sub-tree also.","The total number of comparisons required in the min heap is according to the height of the tree. The height of the complete binary tree is always logn; therefore, the time complexity would also be O(logn)."," ","Operations supported by min \u2013 heap and max \u2013 heap are same. The difference is just that min-heap contains minimum element at root of the tree and max \u2013 heap contains maximum element at the root of the tree.","It is the process to rearrange the elements to maintain the property of heap data structure. It is done when a certain node creates an imbalance in the heap due to some operations on that node. It takes O(log N) to balance the tree. ","This operation also takes O(logN) time.","Examples:","Assume initially heap(taking max-heap) is as follows","           8        /   \\     4     5   / \\1   2","Now if we insert 10 into the heap             8        /      \\      4       5   /  \\      /1    2  10 ","After heapify operation final heap will be look like this           10         /    \\      4      8   /  \\     /1    2  5","It takes O(logN) time.","Example:","Assume initially heap(taking max-heap) is as follows           15         /   \\      5     7   /  \\2     3","Now if we delete 15 into the heap it will be replaced by leaf node of the tree for temporary.           3        /   \\     5     7   /    2","After heapify operation final heap will be look like this           7        /   \\     5     3   /   2","It finds the maximum element or minimum element for max-heap and min-heap respectively and as we know minimum and maximum elements will always be the root node itself for min-heap and max-heap respectively. It takes O(1) time.","This operation returns and deletes the maximum element and minimum element from the max-heap and min-heap respectively. In short, it deletes the root element of the heap binary tree.","The following code shows the implementation of a max-heap.","Let\u2019s understand the maxHeapify function in detail:-","maxHeapify is the function responsible for restoring the property of the Max Heap. It arranges the node i, and its subtrees accordingly so that the heap property is maintained."]},{"lastTimeCrawled":"2024-01-13T15:26:29.564610","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Hashing - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"38d71d34-3bc4-4bcc-a637-81545f823184","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/?ref=outind","content":["Hashing refers to the process of generating a fixed-size output from an input of variable size using the mathematical formulas known as hash functions. This technique determines an index or location for the storage of an item in a data structure.","What is Hashing","Table of Contents/Roadmap","Every day, the data on the internet is increasing multifold and it is always a struggle to store this data efficiently. In day-to-day programming, this amount of data might not be that big, but still, it needs to be stored, accessed, and processed easily and efficiently. A very common data structure that is used for such a purpose is the Array data structure.","Now the question arises if Array was already there, what was the need for a new data structure! The answer to this is in the word \u201cefficiency\u201c. Though storing in Array takes O(1) time, searching in it takes at least O(log n) time. This time appears to be small, but for a large data set, it can cause a lot of problems and this, in turn, makes the Array data structure inefficient. ","So now we are looking for a data structure that can store the data and search in it in constant time, i.e. in O(1) time. This is how Hashing data structure came into play. With the introduction of the Hash data structure, it is now possible to easily store data in constant time and retrieve them in constant time as well.","There are majorly three components of hashing:","Components of Hashing","Suppose we have a set of strings {\u201cab\u201d, \u201ccd\u201d, \u201cefg\u201d} and we would like to store it in a table. ","Our main objective here is to search or update the values stored in the table quickly in O(1) time and we are not concerned about the ordering of strings in the table. So the given set of strings can act as a key and the string itself will act as the value of the string but how to store the value corresponding to the key? ","Mapping key with indices of array","The above technique enables us to calculate the location of a given string by using a simple hash function and rapidly find the value that is stored in that location. Therefore the idea of hashing seems like a great way to store (key, value) pairs of the data in a table.","The hash function creates a mapping between key and value, this is done through the use of mathematical formulas known as hash functions. The result of the hash function is referred to as a hash value or hash. The hash value is a representation of the original string of characters but usually smaller than the original.","For example: Consider an array as a Map where the key is the index and the value is the value at that index. So for an array A if we have index i which will be treated as the key then we can find the value by simply looking at the value at A[i].simply looking up A[i]. ","There are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:","A hash function that maps every item into its own unique slot is known as a perfect hash function. We can construct a perfect hash function if we know the items and the collection will never change but the problem is that there is no systematic way to construct a perfect hash function given an arbitrary collection of items. Fortunately, we will still gain performance efficiency even if the hash function isn\u2019t perfect. We can achieve a perfect hash function by increasing the size of the hash table so that every possible value can be accommodated. As a result, each item will have a unique slot. Although this approach is feasible for a small number of items, it is not practical when the number of possibilities is large.","So, We can construct our hash function to do the same but the things that we must be careful about while constructing our own hash function.","A\u202fgood hash function\u202fshould have the following properties:","If we consider the above example, the hash function we used is the sum of the letters, but if we examined the hash function closely then the problem can be easily visualized that for different strings same hash value is begin generated by the hash function. ","For example: {\u201cab\u201d, \u201cba\u201d} both have the same hash value, and string {\u201ccd\u201d,\u201dbe\u201d} also generate the same hash value, etc. This is known as collision and it creates problem in searching, insertion, deletion, and updating of value. ","The hashing process generates a small number for a big key, so there is a possibility that two keys could produce the same value. The situation where the newly inserted key maps to an already occupied, and it must be handled using some collision handling technology.","What is Collision in Hashing","There are mainly two methods to handle collision: ","Collision resolution technique","The idea is to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.","Example: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.","Let\u2019s see step by step approach to how to solve the above problem:","Hash table","Insert 12","Insert 22","Insert 15","Insert 25","Hence In this way, the separate chaining method is used as the collision resolution technique.","In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.","In linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location. ","Algorithm:","Example: Let us consider a simple hash function as \u201ckey mod 5\u201d and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93. ","Hash table","Insert 50 into hash table","Insert 70 into hash table","Insert 76 into hash table","Insert 85 into hash table","Insert 93 into hash table","Quadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.","An example sequence using quadratic probing is:","H + 12, H + 22, H + 32, H + 42\u2026\u2026\u2026\u2026\u2026\u2026\u2026. H + k2","This method is also known as the mid-square method because in this method we look for i2\u2018th probe (slot) in i\u2019th iteration and the value of i = 0, 1, . . . n \u2013 1. We always start from the original hash location. If only the location is occupied then we check the other slots.","Let hash(x) be the slot index computed using the hash function and n be the size of the hash table.","If the slot hash(x) % n is full, then we try (hash(x) + 12) % n.If (hash(x) + 12) % n is also full, then we try (hash(x) + 22) % n.If (hash(x) + 22) % n is also full, then we try (hash(x) + 32) % n.This process will be repeated for all the values of i until an empty slot is found","Example: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i2 . Insert = 22, 30, and 50","Hash table","Insert key 22 and 30 in the hash table","Insert key 50 in the hash table","Double hashing is a collision resolving technique in Open Addressed Hash tables. Double hashing make use of two hash function, ","This combination of hash functions is of the form ","where ","Complexity of the Double hashing algorithm: ","Example: Insert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is h1\u200b(k) = k mod 7 and second hash-function is h2(k) = 1 + (k mod 5)","Insert key 27 in the hash table","Insert key 43 in the hash table","Insert key 692 in the hash table","Insert key 72 in the hash table","The load factor of the hash table can be defined as the number of items the hash table contains divided by the size of the hash table. Load factor is the decisive parameter that is used when we want to rehash the previous hash function or want to add more elements to the existing hash table.","It helps us in determining the efficiency of the hash function i.e. it tells whether the hash function which we are using is distributing the keys uniformly or not in the hash table.","As the name suggests, rehashing means hashing again. Basically, when the load factor increases to more than its predefined value (the default value of the load factor is 0.75), the complexity increases. So to overcome this, the size of the array is increased (doubled) and all the values are hashed again and stored in the new double-sized array to maintain a low load factor and low complexity.","From the above discussion, we conclude that the goal of hashing is to resolve the challenge of finding an item quickly in a collection. For example, if we have a list of millions of English words and we wish to find a particular term then we would use hashing to locate and find it more efficiently. It would be inefficient to check each item on the millions of lists until we find a match. Hashing reduces search time by restricting the search to a smaller set of words at the beginning."]},{"lastTimeCrawled":"2024-01-13T15:26:30.155459600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Graphs - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"ed19d2b6-c06d-4f62-b533-adaa693a8d07","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/?ref=outind","content":["A Graph is a non-linear data structure consisting of vertices and edges. The vertices are sometimes also referred to as nodes and the edges are lines or arcs that connect any two nodes in the graph. More formally a Graph is composed of a set of vertices( V ) and a set of edges( E ). The graph is denoted by G(V, E).","Graph data structures are a powerful tool for representing and analyzing complex relationships between objects or entities. They are particularly useful in fields such as social network analysis, recommendation systems, and computer networks. In the field of sports data science, graph data structures can be used to analyze and understand the dynamics of team performance and player interactions on the field.","Imagine a game of football as a web of connections, where players are the nodes and their interactions on the field are the edges. This web of connections is exactly what a graph data structure represents, and it\u2019s the key to unlocking insights into team performance and player dynamics in sports.","A graph is known as a null graph if there are no edges in the graph.","Graph having only a single vertex, it is also the smallest graph possible."," ","A graph in which edges do not have any direction. That is the nodes are unordered pairs in the definition of every edge. ","A graph in which edge has direction. That is the nodes are ordered pairs in the definition of every edge.","The graph in which from one node we can visit any other node in the graph is known as a connected graph. ","The graph in which at least one node is not reachable from a node is known as a disconnected graph.","The graph in which the degree of every vertex is equal to K is called K regular graph.","The graph in which from each node there is an edge to each other node.",".","The graph in which the graph is a cycle in itself, the degree of each vertex is 2. ","A graph containing at least one cycle is known as a Cyclic graph.","A Directed Graph that does not contain any cycle. ","A graph in which vertex can be divided into two sets such that vertex in each set does not contain any edge between them.","13. Weighted Graph","          ","Trees are the restricted types of graphs, just with some more rules. Every tree will always be a graph but not all graphs will be trees. Linked List, Trees, and Heaps all are special cases of graphs. ","There are two ways to store a graph:","In this method, the graph is stored in the form of the 2D matrix where rows and columns denote vertices. Each entry in the matrix represents the weight of the edge between those vertices. ","This graph is represented as a collection of linked lists. There is an array of pointer which points to the edges connected to that vertex. ","When the graph contains a large number of edges then it is good to store it as a matrix because only some entries in the matrix will be empty. An algorithm such as Prim\u2019s and Dijkstra adjacency matrix is used to have less complexity.","Below are the basic operations on the graph:","    ","However, there are also some scenarios where using a graph may not be the best approach. For example, if the data being represented is very simple or structured, a graph may be overkill and a simpler data structure may suffice. Additionally, if the graph is very large or complex, it may be difficult or computationally expensive to analyze or traverse, which could make using a graph less desirable."]},{"lastTimeCrawled":"2024-01-13T15:26:31.119478300","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Set \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":300,"pageId":"5460b7c2-7a30-4396-be91-11154748ced7","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-set-data-structure-and-algorithm-tutorials/?ref=outind","content":["DSA for Beginners\nLearn more about Sets in DSA Self Paced Course","In computer science, a set data structure is defined as a data structure that stores a collection of distinct elements.It is a fundamental Data Structure that is used to store and manipulate a group of objects, where each object is unique. The Signature property of the set is that it doesn\u2019t allow duplicate elements.","A set is a mathematical model for a collection of different things; a set contains elements or members, which can be mathematical objects of any kind numbers, symbols, points in space, lines, other geometrical shapes, variables, or even other sets.","A set can be implemented in various ways but the most common ways are:","Set data structures are commonly used in a variety of computer science applications, including algorithms, data analysis, and databases. The main advantage of using a set data structure is that it allows you to perform operations on a collection of elements in an efficient and organized way.","The set data structure can be classified into the following two categories:","An unordered set is an unordered associative container implemented using a hash table where keys are hashed into indices of a hash table so that the insertion is always randomized. All operations on the unordered set take constant time O(1) on an average which can go up to linear time O(n) in the worst case which depends on the internally used hash function, but practically they perform very well and generally provide a constant time lookup operation","An Ordered set is the common set data structure we are familiar with. It is generally implemented using balanced BSTs and it supports O(log n) lookups, insertions and deletion operations.","Sets in C++ internally implemented as (Self-Balancing Binary Search Tree)","Sets in C++ STL are a type of associative container in which each element has to be unique because the value of the element identifies it. The values are stored in a specific sorted order, i.e., ascending or descending.","The std::set class is the part of C++ Standard Template Library (STL) and it is defined inside the <set> header file.","Types of set in C++ STL:","1. set<int>st2. unordered_set<int>st3. multiset<int>st","Syntax:","Datatype: The set can take any data type depending on the values, e.g. int, char, float, etc.","Sets in Java internally implemented as (Hash-Table)","Set is an interface, objects cannot be created of the typeset. We always need a class that extends this list in order to create an object. And also, after the introduction of Generics in Java 1.5, it is possible to restrict the type of object that can be stored in the Set. This type-safe set can be defined as:","Types of set in Java:","1. HashSet2. TreeSet3. LinkedHashSet","Syntax: ","Sets in Python internally implemented as (Hash-Table)","A Set in Python is an unordered collection data type that is iterable, mutable and has no duplicate elements. ","Syntax: ","Sets in C# internally implemented as (Hash-Table)","Set in C# is an unordered collection of unique elements. It comes under System.Collections.Generic namespace. It is used in a situation where we want to prevent duplicates from being inserted in the collection. As far as performance is concerned, it is better in comparison to the list.","Syntax: ","Sets in JavaScript internally implemented as (Hash-Table)","Set in JavaScript is a collection of items that are unique i.e. no element can be repeated. Set in ES6 are ordered: elements of the set can be iterated in the insertion order. A set can store any type of value whether primitive or objects.","Syntax: ","Example:","array = [1,2,2,3,3,4,4,5] // Repeated values","Set = set(array)","SET(1,2,3,4,5) // only unique values","A set is a data structure that stores a collection of unique elements, with no duplicates allowed. Sets can be implemented using a variety of data structures, including arrays, linked lists, binary search trees, and hash tables.","Basically, a Set is language dependent Data Structure. Every language uses a different data structure to implement a set data structure internally like C++ uses Self-Balancing BST. Java, Python, C#, and JavaScript use Hash tables.","Sets in C++ use Self-Balancing Binary Tree(BST). In this approach, the elements are stored in nodes of a binary tree, with the property that the left subtree of any node contains only elements smaller than the node\u2019s value, and the right subtree contains only elements larger than the node\u2019s value. This property ensures that the elements in the tree are always sorted in ascending order.","Internal Implementation of Set Data Structure","In the case of implementation of Set using Hash table (as happens in Python) the implementation happens in the following way:","Here are some common operations that can be performed on a set data structure in C++ using the set container.","You can insert an element into a set using the insert function. For example:","Inserting Elements inside Set Data Structure","For hash table implementations it will be like the following:","Inserting Elements inside Set Data Structure","You can check if an element is present in a set using the count function. The function returns 1 if the element is present, and 0 otherwise.","You can remove an element from a set using the erase function. For example:","Removing an Element from Set Data Structure","In the case of Hash table implementation it will be like the following:","Removing an Element from Set Data Structure","You can find the minimum and maximum elements in a set using the begin and end iterators. The begin iterator points to the first element in the set, and the end iterator points to one past the last element.","Taking out Maximum and Minimum from Set Data Structure","In the case of hash table implementation in Python, the max() and min() functions return the maximum and the minimum respectively.","You can get the size of a set using the size function. ","Below is the Implementation of the above operations:","Some Basic Operations/Terminologies Associated with Set Data Structure","Below is the Implementation of above Operations/Terminologies Associated with Set Data Structure:","Sets are abstract data types that can be used to store unique elements in a collection. Here are some common applications of sets:","1. Find Union and Intersection of two unsorted arrays2. Count distinct elements in an array3. Longest Consecutive Subsequence4. Remove duplicates from sorted array5. K\u2019th Smallest/Largest Element in Unsorted Array","In conclusion, sets are a good choice for algorithms that require unique elements, fast searching, and sorting, but they may not be the best choice for algorithms that require fast insertions, allow duplicates, or have memory constraints. The choice of data structure should depend on the specific requirements of the algorithm.","I"]},{"lastTimeCrawled":"2024-01-13T15:26:32.206569700","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Map \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":265,"pageId":"cc27c1d4-2ff7-4c04-8fe2-1a309616cb44","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-map-data-structure-and-algorithm-tutorials/?ref=outind","content":["DSA for Beginners\nLearn more about Maps in DSA Self Paced Course","Map data structure (also known as a dictionary, associative array, or hash map) is defined as a data structure that stores a collection of key-value pairs, where each key is associated with a single value. ","Maps provide an efficient way to store and retrieve data based on a unique identifier (the key).","The map data structure, also known as a dictionary, is used to store a collection of key-value pairs. It is an essential data structure in computer science because it allows for efficient and fast lookups, inserts, and deletes.","Maps are widely used in many applications, including database indexing, network routing, and web programming. For example, in web programming, a map might be used to store a user\u2019s preferences, where the keys are the preferred names and the values are the preference values. In this case, the map provides a convenient way to store and retrieve user preferences without having to search through a list or array.","There are several different types of maps or dictionary data structures used in computer science and data structures:","A hash map is a data structure that uses a hash function to map keys to indices in an array. The hash function takes the key as input and produces an index into the array, where the corresponding value is stored. Hash maps have an average time complexity of O(1) for operations such as insertion and retrieval, making them one of the most efficient map data structures. However, hash collisions can occur when two keys map to the same index, leading to slower performance in the worst case.","A tree map is a type of map that is implemented as a binary search tree. In a tree map, the keys are stored in a sorted order, allowing for efficient searching, insertion, and deletion operations. Tree maps have an average time complexity of O(log n) for operations such as insertion and retrieval, where n is the number of elements in the map.","A linked hash map is a type of map that maintains a doubly-linked list of the entries in the map, in the order in which they were inserted. This allows for fast iteration over the elements in the map, as well as efficient insertion, retrieval, and deletion operations.","A trie map, also known as a prefix tree, is a type of map that is used to store a set of strings, where each node in the tree represents a prefix of one or more strings. Tries are particularly useful for searching for strings that start with a given prefix, as the search can be terminated early once the prefix is not found in the trie.","A bloom filter map is a type of map that uses a bloom filter, a probabilistic data structure, to determine whether a key is present in the map or not. Bloom filter maps are used when it is important to have a fast response time for key existence checks, but where the occasional false positive result is acceptable.","Maps are associative containers that store elements in a mapped fashion. Each element has a key value and a mapped value. No two mapped values can have the same key values.","Types of Maps in C++:","Syntax:","The map interface is present in java.util package represents a mapping between a key and a value. The Map interface is not a subtype of the Collection interface. Therefore it behaves a bit differently from the rest of the collection types.","Types of Maps in Java:","Syntax: ","map() function returns a map object(which is an iterator) of the results after applying the given function to each item of a given iterable (list, tuple etc.)","Syntax: ","The Dictionary<TKey, TValue> Class in C# is a collection of Keys and Values. It is a generic collection class in the System.Collections.Generic namespace. The Dictionary <TKey, TValue> generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key.","Map is a collection of elements where each element is stored as a Key, value pair. Map object can hold both objects and primitive values as either key or value. When we iterate over the map object it returns the key, value pair in the same order as inserted.","Syntax: ","Duplicate Values","Unique Values"," keys are unique, but the values can be duplicated","Ordered Collection","Unordered Collection","Unordered Collection","Static","Dynamic","Dynamic","Elements in an array can be accessed using their index","Iterate over the set to retrieve the value.","Elements can be retrieved using their key","Adding, removing, and accessing elements","Set operations like union, intersection, and difference.","Maps are used for operations like adding, removing, and accessing key-value pairs.","Stored as contiguous blocks of memory","Implemented using linked lists or trees","Implemented using linked lists or trees","The Map data structure is a collection of key-value pairs that allows fast access to the values based on their corresponding keys. The internal implementation of the Map data structure depends on the programming language or library being used.","Map data structure is typically implemented as an associative array or hash table, which uses a hash function to compute a unique index for each key-value pair. This index is then used to store and retrieve the value associated with that key.","Map Data Structure","When a new key-value pair is added to the Map, the hash function is applied to the key to compute its index, and the value is stored at that index. If there is already a value stored at that index, then the new value replaces the old one.","In C++, an ordered map is implemented using the std::map container provided in the Standard Template Library (STL). The std::map is a templated container that stores key-value pairs in a sorted order based on the keys.","Ordered Map","Here is an example of how to declare an ordered map in C++:","In C++, an unordered map is implemented using the std::unordered_map container provided in the Standard Template Library (STL). The std::unordered_map is a templated container that stores key-value pairs in an unordered manner based on the hash values of the keys.","Unordered Map","Here is an example of how to declare an unordered map in C++:","A map is a data structure that allows you to store key-value pairs. Here are some common operations that you can perform with a map:","Below is the Implementation of the above Operations:","Here are some of the properties of the map data structure:","1. Indexing and retrieval: Maps are used to index elements in an array and retrieve elements based on their keys.","2. Grouping and categorization: Maps can be used to group elements and categorize them into different buckets. For example, you can group employees based on their departments, cities, or salary ranges.","3. Network routing: Maps are used in computer networks to store information about routes between nodes. The information stored in the map can be used to find the shortest path between two nodes.","4. Graph algorithms: Maps can be used to represent graphs and perform graph algorithms, such as depth-first search and breadth-first search.","Time Complexity:"," ","O(N)","O(1)","O(1)","O(N)","O(1)","O(1)","O(N)","O(1)","O(1)","O(N)","O(1)","O(1)","O(logN)","O(logN)","O(1)","O(logN)","O(logN)","O(1)","O(logN)","O(logN)","O(1)","I"]},{"lastTimeCrawled":"2024-01-13T15:26:32.401592900","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Advanced Data Structures - GeeksforGeeks","rating":265,"pageId":"f8a42fe8-7e1f-4c71-889e-1f5e6b0ce8ed","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/advanced-data-structures/?ref=outind","content":["Learn Data Structures and Algorithms | DSA TutorialLearn more about Advanced Data Structures in DSA Self Paced CoursePractice Problems on all Advanced Data Structure","Advanced Data Structures are used to store and manage data in an efficient and organized way for faster and easier access and modification of Data. Some of the basic data structures are Arrays, LinkedList, Stacks, Queues, etc.","This page will contain some of the complex and Advanced Data Structures like Disjoint Sets, Self-Balancing Trees, Segment Trees, Tries etc.","Table of Content","Quick Links:","Recomended:","H"]},{"lastTimeCrawled":"2024-01-13T15:26:33.204670","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Data Structures - GeeksforGeeks","rating":283,"pageId":"187ed38c-0de7-42f7-95e5-f818c6e21ea9","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-data-structures/?ref=outind","content":["A data structure is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexities of different tasks. ","The choice of a good data structure makes it possible to perform a variety of critical operations effectively. An efficient data structure also uses minimum memory space and execution time to process the structure. A data structure is not only used for organising the data. It is also used for processing, retrieving, and storing data. There are different basic and advanced types of data structures that are used in almost every program or software system that has been developed. So we must have good knowledge of data structures.","The structure of the data and the synthesis of the algorithm are relative to each other. Data presentation must be easy to understand so the developer, as well as the user, can make an efficient implementation of the operation.Data structures provide an easy way of organising, retrieving, managing, and storing data.","Here is a list of the needs for data.","An array is a collection of data items stored at contiguous memory locations. The idea is to store multiple items of the same type together. This makes it easier to calculate the position of each element by simply adding an offset to a base value, i.e., the memory location of the first element of the array (generally denoted by the name of the array). ","Array Data Structure","Like arrays, Linked List is a linear data structure. Unlike arrays, linked list elements are not stored at a contiguous location; the elements are linked using pointers. ","Linked Data Structure","Stack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out). In stack, all insertion and deletion are permitted at only one end of the list.","Stack Operations:","Like Stack, Queue is a linear structure which follows a particular order in which the operations are performed. The order is First In First Out (FIFO). In the queue, items are inserted at one end and deleted from the other end. A good example of the queue is any queue of consumers for a resource where the consumer that came first is served first. The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added. ","Queue Data Structure","Queue Operations:","Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures. A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. It is implemented mainly using Links. ","A Binary Tree is represented by a pointer to the topmost node in the tree. If the tree is empty, then the value of root is NULL. A Binary Tree node contains the following parts. ","Binary Tree Data Structure","A Binary Search Tree is a Binary Tree following the additional properties: ","A Binary tree having the following properties is known as Binary search tree (BST).","Binary Search Tree Data Structure","A Heap is a special Tree-based data structure in which the tree is a complete binary tree. Generally, Heaps can be of two types: ","Max and Min Heap","Hashing is an important Data Structure which is designed to use a special function called the Hash function which is used to map a given value with a particular key for faster access of elements. The efficiency of mapping depends on the efficiency of the hash function used. ","Let a hash function H(x) maps the value x at the index x%10 in an Array. For example, if the list of values is [11, 12, 13, 14, 15] it will be stored at positions {1, 2, 3, 4, 5} in the array or Hash table respectively. ","Hash Data Structure","A matrix represents a collection of numbers arranged in an order of rows and columns. It is necessary to enclose the elements of a matrix in parentheses or brackets. ","A matrix with 9 elements is shown below. ","Matrix","Trie is an efficient information retrieval data structure. Using Trie, search complexities can be brought to an optimal limit (key length). If we store keys in the binary search tree, a well-balanced BST will need time proportional to M * log N, where M is maximum string length and N is the number of keys in the tree. Using Trie, we can search the key in O(M) time. However, the penalty is on Trie storage requirements. ","Trie Data Structure","Data structures are used in various fields such as:","M"]},{"lastTimeCrawled":"2024-01-13T15:26:33.429427200","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Design and Analysis of Algorithms - GeeksforGeeks","rating":283,"pageId":"447b053f-387d-4b1f-a88b-f1853fceb120","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/?ref=outind","content":["Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Analysis of algorithms is the determination of the amount of time and space resources required to execute it.","Basics on Analysis of Algorithms:","Asymptotic Notations:","Some Advance topics:","Complexity Proofs:","If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.","Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"]},{"lastTimeCrawled":"2024-01-13T15:26:34.323656500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Asymptotic Notation and Analysis (Based on input size) in Complexity Analysis of Algorithms - GeeksforGeeks","rating":332,"pageId":"e3cb6fac-25e7-44fa-877e-c5c232978edc","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/analysis-of-algorithms-set-1-asymptotic-analysis/?ref=outind","content":["Asymptotic Analysis is defined as the big idea that handles the above issues in analyzing algorithms. In Asymptotic Analysis, we evaluate the performance of an algorithm in terms of input size (we don\u2019t measure the actual running time). We calculate, how the time (or space) taken by an algorithm increases with the input size. ","Asymptotic notation is a way to describe the running time or space complexity of an algorithm based on the input size. It is commonly used in complexity analysis to describe how an algorithm performs as the size of the input grows. The three most commonly used notations are Big O, Omega, and Theta.","In general, the choice of asymptotic notation depends on the problem and the specific algorithm used to solve it. It is important to note that asymptotic notation does not provide an exact running time or space usage for an algorithm, but rather a description of how the algorithm scales with respect to input size. It is a useful tool for comparing the efficiency of different algorithms and for predicting how they will perform on large input sizes.","There are many important things that should be taken care of, like user-friendliness, modularity, security, maintainability, etc. Why worry about performance?  The answer to this is simple, we can have all the above things only if we have performance. So performance is like currency through which we can buy all the above things. Another reason for studying performance is \u2013 speed is fun! To summarize, performance == scale. Imagine a text editor that can load 1000 pages, but can spell check 1 page per minute OR an image editor that takes 1 hour to rotate your image 90 degrees left OR \u2026 you get it. If a software feature can not cope with the scale of tasks users need to perform \u2013 it is as good as dead. ","The way to study the efficiency of an algorithm is to implement it and experiment by running the program on various test inputs while recording the time spent during each execution. A simple mechanism in Java is based on use of the currentTimeMillis() method of the System class  for collecting such running times. That method reports the number of milliseconds that have passed since a benchmark time knownas the epoch (January 1, 1970 UTC).The key is that if we record the time immediately before executing the algorithm and then immediately after it.","long start = System.currentTimeMillis( ); // record the starting time /? (run the algorithm) ?/ long end = System.currentTimeMillis( ); // record the ending time long elapsed = end ? start; //Total time elapsed","Measuring elapsed time  provides a reasonable reflection of an algorithm\u2019s efficiency.","One naive way of doing this is \u2013 to implement both the algorithms and run the two programs on your computer for different inputs and see which one takes less time. There are many problems with this approach for the analysis of algorithms. ","Asymptotic Analysis is the big idea that handles the above issues in analyzing algorithms. In Asymptotic Analysis, we evaluate the performance of an algorithm in terms of input size (we don\u2019t measure the actual running time). We calculate, how the time (or space) taken by an algorithm increases with the input size. ","For example, let us consider the search problem (searching a given item) in a sorted array. ","The solution to above search problem includes: ","To understand how Asymptotic Analysis solves the problems mentioned above in analyzing algorithms, ","Running times for this example: ","Experimental running times of two algorithms are difficult to directly compare unless the experiments are performed in the same hardware and software environments. Experiments can be done only on a limited set of test inputs; hence, they leave out the running times of inputs not included in the experiment (and these inputs may be important).","To overcome the challenges in the Experimental analysis Asymptotic Analysis is used.","Asymptotic Analysis is not perfect, but that\u2019s the best way available for analyzing algorithms. For example, say there are two sorting algorithms that take 1000nLogn and 2nLogn time respectively on a machine. Both of these algorithms are asymptotically the same (order of growth is nLogn). So, With Asymptotic Analysis, we can\u2019t judge which one is better as we ignore constants in Asymptotic Analysis. ","Also, in Asymptotic analysis, we always talk about input sizes larger than a constant value. It might be possible that those large inputs are never given to your software and an asymptotically slower algorithm always performs better for your particular situation. So, you may end up choosing an algorithm that is Asymptotically slower but faster for your software.","Disadvantages:"]},{"lastTimeCrawled":"2024-01-13T15:26:35.440330600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Types of Asymptotic Notations in Complexity Analysis of Algorithms - GeeksforGeeks","rating":316,"pageId":"5ef6ac68-b627-4562-b2a7-47dbd7b5960a","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/?ref=outind","content":["We have discussed Asymptotic Analysis, and Worst, Average, and Best Cases of Algorithms. The main idea of asymptotic analysis is to have a measure of the efficiency of algorithms that don\u2019t depend on machine-specific constants and don\u2019t require algorithms to be implemented and time taken by programs to be compared. Asymptotic notations are mathematical tools to represent the time complexity of algorithms for asymptotic analysis.","Asymptotic Notations:",".Asymptotic Notations are mathematical tools that allow you to analyze an algorithm\u2019s running time by identifying its behavior as its input size grows.",".This is also referred to as an algorithm\u2019s growth rate.",".You can\u2019t compare two algorithm\u2019s head to head.",".You compare space and time complexity using asymptotic analysis.",".It compares two algorithms based on changes in their performance as the input size is increased or decreased.","There are mainly three asymptotic notations:","Theta notation encloses the function from above and below. Since it represents the upper and the lower bound of the running time of an algorithm, it is used for analyzing the average-case complexity of an algorithm.",".Theta (Average Case) You add the running times for each possible input combination and take the average in the average case.","Let g and f be the function from the set of natural numbers to itself. The function f is said to be Θ(g), if there are constants c1, c2 > 0 and a natural number n0 such that c1* g(n) ≤ f(n) ≤ c2 * g(n) for all n ≥ n0","Theta notation","Θ (g(n)) = {f(n): there exist positive constants c1, c2 and n0 such that 0 ≤ c1 * g(n) ≤ f(n) ≤ c2 * g(n) for all n ≥ n0}","Note: Θ(g) is a set","The above expression can be described as if f(n) is theta of g(n), then the value f(n) is always between c1 * g(n) and c2 * g(n) for large values of n (n ≥ n0). The definition of theta also requires that f(n) must be non-negative for values of n greater than n0.","The execution time serves as both a lower and upper bound on the algorithm\u2019s time complexity. ","It exist as both, most, and least boundaries for a given input value.","A simple way to get the Theta notation of an expression is to drop low-order terms and ignore leading constants. For example, Consider the expression 3n3 + 6n2 + 6000 = Θ(n3), the dropping lower order terms is always fine because there will always be a number(n) after which Θ(n3) has higher values than Θ(n2) irrespective of the constants involved. For a given function g(n), we denote Θ(g(n)) is following set of functions. ","Examples :","{ 100 , log (2000) , 10^4 } belongs to Θ(1){ (n/4) , (2n+3) , (n/100 + log(n)) } belongs to Θ(n){ (n^2+n) , (2n^2) , (n^2+log(n))} belongs to Θ( n2)","Note: Θ provides exact bounds.","Big-O notation represents the upper bound of the running time of an algorithm. Therefore, it gives the worst-case complexity of an algorithm.",".It is the most widely used notation for Asymptotic analysis..It specifies the upper bound of a function..The maximum time required by an algorithm or the worst-case time complexity..It returns the highest possible output value(big-O) for a given input..Big-Oh(Worst Case) It is defined as the condition that allows an algorithm to complete statement execution in the longest amount of time possible. ","If f(n) describes the running time of an algorithm, f(n) is O(g(n)) if there exist a positive constant C and n0 such that, 0 ≤ f(n) ≤ cg(n) for all n ≥ n0","It returns the highest possible output value (big-O)for a given input.","The execution time serves as an upper bound on the algorithm\u2019s time complexity.","O(g(n)) = { f(n): there exist positive constants c and n0 such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0 }","For example, Consider the case of Insertion Sort. It takes linear time in the best case and quadratic time in the worst case. We can safely say that the time complexity of the Insertion sort is O(n2). Note: O(n2) also covers linear time. ","If we use Θ notation to represent the time complexity of Insertion sort, we have to use two statements for best and worst cases: ","The Big-O notation is useful when we only have an upper bound on the time complexity of an algorithm. Many times we easily find an upper bound by simply looking at the algorithm.  "," Examples :","{ 100 , log (2000) , 10^4 } belongs to O(1)U { (n/4) , (2n+3) , (n/100 + log(n)) } belongs to O(n)U { (n^2+n) , (2n^2) , (n^2+log(n))} belongs to O( n^2) ","Note: Here, U represents union, we can write it in these manner because O provides exact or upper bounds .","Omega notation represents the lower bound of the running time of an algorithm. Thus, it provides the best case complexity of an algorithm.","The execution time serves as a lower bound on the algorithm\u2019s time complexity.","It is defined as the condition that allows an algorithm to complete statement execution in the shortest amount of time.","Let g and f be the function from the set of natural numbers to itself. The function f is said to be Ω(g), if there is a constant c > 0 and a natural number n0 such that c*g(n) ≤ f(n) for all n ≥ n0","Ω(g(n)) = { f(n): there exist positive constants c and n0 such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0 }","Let us consider the same Insertion sort example here. The time complexity of Insertion Sort can be written as Ω(n), but it is not very useful information about insertion sort, as we are generally interested in worst-case and sometimes in the average case. ","Examples :","{ (n^2+n) , (2n^2) , (n^2+log(n))} belongs to Ω( n^2)U { (n/4) , (2n+3) , (n/100 + log(n)) } belongs to Ω(n)U { 100 , log (2000) , 10^4 } belongs to Ω(1)","Note: Here, U represents union, we can write it in these manner because Ω provides exact or lower bounds.","If f(n) is O(g(n)) then a*f(n) is also O(g(n)), where a is a constant.","Example:","f(n) = 2n²+5 is O(n²) then, 7*f(n) = 7(2n²+5) = 14n²+35 is also O(n²).","Similarly, this property satisfies both Θ and Ω notation.","We can say,","If f(n) is Θ(g(n)) then a*f(n) is also Θ(g(n)), where a is a constant. If f(n) is Ω (g(n)) then a*f(n) is also Ω (g(n)), where a is a constant.","If f(n) is O(g(n)) and g(n) is O(h(n)) then f(n) = O(h(n)).","Example:","If f(n) = n, g(n) = n² and h(n)=n³n is O(n²) and n² is O(n³) then, n is O(n³)","Similarly, this property satisfies both Θ and Ω notation.","We can say,","If f(n) is Θ(g(n)) and g(n) is Θ(h(n)) then f(n) = Θ(h(n)) .If f(n) is Ω (g(n)) and g(n) is Ω (h(n)) then f(n) = Ω (h(n))","Reflexive properties are always easy to understand after transitive.If f(n) is given then f(n) is O(f(n)). Since MAXIMUM VALUE OF f(n) will be f(n) ITSELF!Hence x = f(n) and y = O(f(n) tie themselves in reflexive relation always.","Example:","f(n) = n² ; O(n²) i.e O(f(n))Similarly, this property satisfies both Θ and Ω notation.   ","We can say that,","If f(n) is given then f(n) is Θ(f(n)).If f(n) is given then f(n) is Ω (f(n)).","If f(n) is Θ(g(n)) then g(n) is Θ(f(n)).","Example:","If(n) = n² and g(n) = n²then, f(n) = Θ(n²) and g(n) = Θ(n²)","This property only satisfies for Θ notation.","If f(n) is O(g(n)) then g(n) is Ω (f(n)).","Example:","If(n) = n , g(n) = n²then n is O(n²) and n² is Ω (n) ","This property only satisfies O and Ω notations.","1. If f(n) = O(g(n)) and f(n) = Ω(g(n)) then f(n) = Θ(g(n))2. If f(n) = O(g(n)) and d(n)=O(e(n)) then f(n) + d(n) = O( max( g(n), e(n) )) ","Example:","f(n) = n i.e O(n) d(n) = n² i.e O(n²) then f(n) + d(n) = n + n² i.e O(n²)","3. If f(n)=O(g(n)) and d(n)=O(e(n)) then f(n) * d(n) = O( g(n) * e(n))","Example: ","f(n) = n i.e O(n) d(n) = n² i.e O(n²)then f(n) * d(n) = n * n² = n³ i.e O(n³)_______________________________________________________________________________Note: If  f(n) = O(g(n)) then g(n) = Ω(f(n))  ","Important Links :","For more details, please refer: Design and Analysis of Algorithms."]},{"lastTimeCrawled":"2024-01-13T15:26:36.233922500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Worst, Average and Best Case Analysis of Algorithms - GeeksforGeeks","rating":316,"pageId":"c9010104-f213-4871-bd5f-3b5c1090bd2d","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/analysis-of-algorithms-set-2-asymptotic-analysis/?ref=outind","content":["In the previous post, we discussed how Asymptotic analysis overcomes the problems of the naive way of analyzing algorithms. But let\u2019s take an overview of the asymptotic notation and learn about What is Worst, Average, and Best cases of an algorithm:","We define an algorithm\u2019s worst-case time complexity by using the Big-O notation, which determines the set of functions grows slower than or at the same rate as the expression. Furthermore, it explains the maximum amount of time an algorithm requires to consider all input values.","It defines the best case of an algorithm\u2019s time complexity, the Omega notation defines whether the set of functions will grow faster or at the same rate as the expression. Furthermore, it explains the minimum amount of time an algorithm requires to consider all input values.","It defines the average case of an algorithm\u2019s time complexity, the Theta notation defines when the set of functions lies in both O(expression) and Omega(expression), then Theta notation is used. This is how we define a time complexity average case for an algorithm. ","Based on the above three notations of Time Complexity there are three cases to analyze an algorithm:","In the worst-case analysis, we calculate the upper bound on the running time of an algorithm. We must know the case that causes a maximum number of operations to be executed. For Linear Search, the worst case happens when the element to be searched (x) is not present in the array. When x is not present, the search() function compares it with all the elements of arr[] one by one. Therefore, the worst-case time complexity of the linear search would be O(n).","In the best-case analysis, we calculate the lower bound on the running time of an algorithm. We must know the case that causes a minimum number of operations to be executed. In the linear search problem, the best case occurs when x is present at the first location. The number of operations in the best case is constant (not dependent on n). So time complexity in the best case would be ?(1) ","In average case analysis, we take all possible inputs and calculate the computing time for all of the inputs. Sum all the calculated values and divide the sum by the total number of inputs. We must know (or predict) the distribution of cases. For the linear search problem, let us assume that all cases are uniformly distributed (including the case of x not being present in the array). So we sum all the cases and divide the sum by (n+1). Following is the value of average-case time complexity.  ","Average Case Time = \\sum_{i=1}^{n}\\frac{\\theta (i)}{(n+1)} = \\frac{\\theta (\\frac{(n+1)*(n+2)}{2})}{(n+1)} = \\theta (n)","Below is the ranked mention of complexity analysis notation based on popularity:","Most of the time, we do worst-case analyses to analyze algorithms. In the worst analysis, we guarantee an upper bound on the running time of an algorithm which is good information. ","The average case analysis is not easy to do in most practical cases and it is rarely done. In the average case analysis, we must know (or predict) the mathematical distribution of all possible inputs. ","The Best Case analysis is bogus. Guaranteeing a lower bound on an algorithm doesn\u2019t provide any information as in the worst case, an algorithm may take years to run.","A) For some algorithms, all the cases (worst, best, average) are asymptotically the same. i.e., there are no worst and best cases. ","B) Where as most of the other sorting algorithms have worst and best cases. ","Time Complexity Analysis: (In Big-O notation)","2. In this example, we will take an array of length (n) and deals with the following cases :","Below is the implementation of the given problem:","Time Complexity Analysis:","For more details, please refer: Design and Analysis of Algorithms.","Worst, Average, and Best Case Analysis of Algorithms is a technique used to analyze the performance of algorithms under different conditions. Here are some advantages, disadvantages, important points, and reference books related to this analysis technique:"]},{"lastTimeCrawled":"2024-01-13T15:26:36.569361900","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Linear Search Algorithm - Data Structure and Algorithms Tutorials - GeeksforGeeks","rating":283,"pageId":"159fcc2d-53bd-416e-9cbf-2ce714a93b21","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/linear-search/?ref=outind","content":["Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set.","Linear Search Algorithm","In Linear Search Algorithm, ","For example: Consider the array arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30","Step 1: Start from the first element (index 0) and compare key with each element (arr[i]).","Compare key with arr[0]","Compare key with arr[1]","Step 2: Now when comparing arr[2] with key, the value matches. So the Linear Search Algorithm will yield a successful message and return the index of the element when key is found (here 2).","Compare key with arr[2]","Below is the implementation of the linear search algorithm:","Time Complexity:","Auxiliary Space: O(1) as except for the variable to iterate through the list, no other variable is used. "]},{"lastTimeCrawled":"2024-01-13T15:26:37.110608600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Binary Search - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":300,"pageId":"2cbba4fa-6f40-4a92-a45d-0e48c46f6cc3","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/binary-search/?ref=outind","content":["Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). ","Example of Binary Search Algorithm","To apply Binary Search algorithm:","In this algorithm, ","Finding the middle index \u201cmid\u201d in Binary Search Algorithm","To understand the working of binary search, consider the following illustration:","Consider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, and the target = 23.","First Step: Calculate the mid and compare the mid element with the key. If the key is less than mid element, move to left and if it is greater than the mid then move search space to the right.","Binary Search Algorithm : Compare key with 16","Binary Search Algorithm : Compare key with 56","Second Step: If the key matches the value of the mid element, the element is found and stop search.","Binary Search Algorithm : Key matches with mid","The Binary Search Algorithm can be implemented in the following two ways","Given below are the pseudocodes for the approaches.","Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves.","Implementation of Iterative  Binary Search Algorithm: ","Time Complexity: O(log N)Auxiliary Space: O(1)","Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space.","Implementation of Recursive  Binary Search Algorithm:","Follow the link to know about Binary Search on Answers"]},{"lastTimeCrawled":"2024-01-13T15:26:37.430284700","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Searching Algorithms - GeeksforGeeks","rating":265,"pageId":"bd75bacd-2bdf-40fd-8481-c0c7070016df","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/searching-algorithms/?ref=outind","content":["Learn Data Structures and Algorithms | DSA Tutorial\nLearn more about Searching Algorithms in DSA Self Paced Course\nPractice Problems on Searching Algorithms\nTop Quizzes on Searching Algorithms","Searching Algorithms are designed to check for an element or retrieve an element from any data structure where it is stored.","Searching Algorithms","Based on the type of search operation, these algorithms are generally classified into two categories:","Linear Search to find the element \u201c20\u201d in a given list of numbers","Linear-Search","Binary Search to find the element \u201c23\u201d in a given list of numbers","Binary Search","Topic :","Searching Algorithm:","Comparisons:","Library Implementations of Searching Algorithms :","Some standard problems on Searching:","Quick Links:","Recomended:","If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above."]},{"lastTimeCrawled":"2024-01-13T15:26:37.843095300","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Selection Sort \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"6cb490d2-541f-49a8-9ee2-751b12778ab2","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/selection-sort/?ref=outind","content":["Selection sort is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. ","The algorithm repeatedly selects the smallest (or largest) element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted. ","Lets consider the following array as an example: arr[] = {64, 25, 12, 22, 11}","First pass:","Selection Sort Algorithm | Swapping 1st element with the minimum in array","Second Pass:","Selection Sort Algorithm | swapping i=1 with the next minimum element","Third Pass:","Selection Sort Algorithm | swapping i=2 with the next minimum element","Fourth pass:","Selection Sort Algorithm | swapping i=3 with the next minimum element","Fifth Pass:","Selection Sort Algorithm | Required sorted array","Below is the implementation of the above approach:","Time Complexity: The time complexity of Selection Sort is O(N2) as there are two nested loops:","Auxiliary Space: O(1) as the only extra memory used is for temporary variables while swapping two values in Array. The selection sort never makes more than O(N) swaps and can be useful when memory writing is costly. ","Q1. Is Selection Sort Algorithm stable?","The default implementation of the Selection Sort Algorithm is not stable. However, it can be made stable. Please see the stable Selection Sort for details.","Q2. Is Selection Sort Algorithm in-place?","Yes, Selection Sort Algorithm is an in-place algorithm, as it does not require extra space."]},{"lastTimeCrawled":"2024-01-13T15:26:38.370541600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Bubble Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"32fbb53f-ccdd-4dc6-a80c-80ec894f0a2d","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/bubble-sort/?ref=outind","content":["Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.","In Bubble Sort algorithm, ","Let us understand the working of bubble sort with the help of the following illustration:","Input: arr[] = {6, 3, 0, 5}","First Pass: ","The largest element is placed in its correct position, i.e., the end of the array.","Bubble Sort Algorithm : Placing the largest element at correct position","Second Pass: ","Place the second largest element at correct position","Bubble Sort Algorithm : Placing the second largest element at correct position","Third Pass:","Place the remaining two elements at their correct positions.","Bubble Sort Algorithm : Placing the remaining elements at their correct positions","Below is the implementation of the bubble sort. It can be optimized by stopping the algorithm if the inner loop didn\u2019t cause any swap. ","Time Complexity: O(N2)Auxiliary Space: O(1)","Bubble sort takes minimum time (Order of n) when elements are already sorted. Hence it is best to check if the array is already sorted or not beforehand, to avoid O(N2) time complexity.","Yes, Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. Hence Bubble sort algorithm is an in-place algorithm.","Yes, the bubble sort algorithm is stable.","Due to its simplicity, bubble sort is often used to introduce the concept of a sorting algorithm. In computer graphics, it is popular for its capability to detect a tiny error (like a swap of just two elements) in almost-sorted arrays and fix it with just linear complexity (2n). ","Example: It is used in a polygon filling algorithm, where bounding lines are sorted by their x coordinate at a specific scan line (a line parallel to the x-axis), and with incrementing y their order changes (two elements are swapped) only at intersections of two lines.","Related Articles: "]},{"lastTimeCrawled":"2024-01-13T15:26:38.785721600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Insertion Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":265,"pageId":"e74249a2-5af7-4122-9383-b67e4c6f4b87","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/insertion-sort/?ref=outind","content":["Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.","To sort an array of size N in ascending order iterate over the array and compare the current element (key) to its predecessor, if the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.","Consider an example: arr[]: {12, 11, 13, 5, 6}","First Pass:","Second Pass:","Third Pass:","Fourth Pass:","Illustrations:"," ","Below is the implementation of the iterative approach:","Time Complexity: O(N^2) Auxiliary Space: O(1)","The auxiliary space complexity of Insertion Sort is O(1)","Q1. What are the Boundary Cases of the Insertion Sort algorithm?","Insertion sort takes the maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. ","Q2. What is the Algorithmic Paradigm of the Insertion Sort algorithm?","The Insertion Sort algorithm follows an incremental approach.","Q3. Is Insertion Sort an in-place sorting algorithm?","Yes, insertion sort is an in-place sorting algorithm.","Q4. Is Insertion Sort a stable algorithm?","Yes, insertion sort is a stable sorting algorithm.","Q5. When is the Insertion Sort algorithm used?","Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, and only a few elements are misplaced in a complete big array."]},{"lastTimeCrawled":"2024-01-13T15:26:39.282747600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Merge Sort - Data Structure and Algorithms Tutorials - GeeksforGeeks","rating":265,"pageId":"8cc48745-32b4-450f-821b-7eba8d93569b","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/merge-sort/?ref=outind","content":["Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array.","In simple terms, we can say that the process of merge sort is to divide the array into two halves, sort each half, and then merge the sorted halves back together. This process is repeated until the entire array is sorted.","Merge Sort Algorithm","Merge sort is a recursive algorithm that continuously splits the array in half until it cannot be further divided i.e., the array has only one element left (an array with one element is always sorted). Then the sorted subarrays are merged into one sorted array.","See the below illustration to understand the working of merge sort.","Illustration:","Lets consider an array arr[] = {38, 27, 43, 10}","Merge Sort: Divide the array into two halves","Merge Sort: Divide the subarrays into two halves (unit length subarrays here)","These sorted subarrays are merged together, and we get bigger sorted subarrays.","Merge Sort: Merge the unit length subarrys into sorted subarrays","This merging process is continued until the sorted array is built from the smaller subarrays.","Merge Sort: Merge the sorted subarrys to get the sorted array","The following diagram shows the complete merge sort process for an example array {38, 27, 43, 10}. ","Below is the Code implementation of Merge Sort.","Time Complexity: O(N log(N)),  Merge Sort is a recursive algorithm and time complexity can be expressed as following recurrence relation. ","T(n) = 2T(n/2) + θ(n)","The above recurrence can be solved either using the Recurrence Tree method or the Master method. It falls in case II of the Master Method and the solution of the recurrence is θ(Nlog(N)). The time complexity of Merge Sort isθ(Nlog(N)) in all 3 cases (worst, average, and best) as merge sort always divides the array into two halves and takes linear time to merge two halves.","Auxiliary Space: O(N), In merge sort all elements are copied into an auxiliary array. So N auxiliary space is required for merge sort.","Quick Links:"]},{"lastTimeCrawled":"2024-01-13T15:26:39.814142800","images":[{"src":"https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/01/QuickSort2.png","alt":"How Quicksort works"}],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"QuickSort - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":303,"pageId":"72928f07-fb27-484c-b244-cfff7e79ebf4","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/quick-sort/?ref=outind","content":["QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.","The key process in quickSort is a partition(). The target of partitions is to place the pivot (any element can be chosen to be a pivot) at its correct position in the sorted array and put all smaller elements to the left of the pivot, and all greater elements to the right of the pivot.","Partition is done recursively on each side of the pivot after the pivot is placed in its correct position and this finally sorts the array.","How Quicksort works","There are many different choices for picking pivots. ","The logic is simple, we start from the leftmost element and keep track of the index of smaller (or equal) elements as i. While traversing, if we find a smaller element, we swap the current element with arr[i]. Otherwise, we ignore the current element.","Let us understand the working of partition and the Quick Sort algorithm with the help of the following example:","Consider: arr[] = {10, 80, 30, 90, 40}.","Partition in QuickSort: Compare pivot with 10","Partition in QuickSort: Compare pivot with 80","Partition in QuickSort: Compare pivot with 30","Partition in QuickSort: Compare pivot with 90","Partition in QuickSort: Place pivot in its correct position","As the partition process is done recursively, it keeps on putting the pivot in its actual position in the sorted array. Repeatedly putting pivots in their actual position makes the array sorted.","Follow the below images to understand how the recursive implementation of the partition algorithm helps to sort the array.","Quicksort: Performing the partition","Quicksort: Performing the partition","Time Complexity:"]},{"lastTimeCrawled":"2024-01-13T15:26:40.507637600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks","rating":283,"pageId":"feb88bf2-546a-4bc3-ab16-4191a2d1fab0","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/heap-sort/?ref=outind","content":["Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.","To solve the problem follow the below idea:","First convert the array into heap data structure using heapify, then one by one delete the root node of the Max-heap and replace it with the last node in the heap and then heapify the root of the heap. Repeat this process until size of heap is greater than 1.","To understand heap sort more clearly, let\u2019s take an unsorted array and try to sort it using heap sort.Consider the array: arr[] = {4, 10, 3, 5, 1}.","Build Complete Binary Tree: Build a complete binary tree from the array.","Heap sort algorithm | Build Complete Binary Tree","Transform into max heap: After that, the task is to construct a tree from that unsorted array and try to convert it into max heap.","Heap sort algorithm | Max Heapify constructed binary tree","Perform heap sort: Remove the maximum element in each step (i.e., move it to the end position and remove that) and then consider the remaining elements and transform it into a max heap.","Heap sort algorithm | Remove maximum from root and max heapify","Heap sort algorithm | Remove next maximum from root nad max heapify","Heap sort algorithm | Repeat previous step","Heap sort algorithm | Final sorted array","Time Complexity: O(N log N)Auxiliary Space: O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation.","Q1. What are the two phases of Heap Sort?","The heap sort algorithm consists of two phases. In the first phase, the array is converted into a max heap. And in the second phase, the highest element is removed (i.e., the one at the tree root) and the remaining elements are used to create a new max heap.","Q2. Why Heap Sort is not stable?","The heap sort algorithm is not a stable algorithm. This algorithm is not stable because the operations that are performed in a heap can change the relative ordering of the equivalent keys.","Q3. Is Heap Sort an example of the \u201cDivide and Conquer\u201d algorithm?","Heap sort is NOT at all a Divide and Conquer algorithm. It uses a heap data structure to efficiently sort its element and not a \u201cdivide and conquer approach\u201d to sort the elements.","Q4. Which sorting algorithm is better \u2013 Heap sort or Merge Sort?","The answer lies in the comparison of their time complexity and space requirements. The Merge sort is slightly faster than the Heap sort. But on the other hand merge sort takes extra memory. Depending on the requirement, one should choose which one to use.","Q5. Why is Heap sort better than Selection sort?","Heap sort is similar to selection sort, but with a better way to get the maximum element. It takes advantage of the heap data structure to get the maximum element in constant time "]},{"lastTimeCrawled":"2024-01-13T15:26:40.905451700","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Counting Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks","rating":283,"pageId":"588810f3-63db-47f0-a70f-3b62ed93972e","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/counting-sort/?ref=outind","content":["Counting Sort is a non-comparison-based sorting algorithm that works well when there is limited range of input values. It is particularly efficient when the range of input values is small compared to the number of elements to be sorted. The basic idea behind Counting Sort is to count the frequency of each distinct element in the input array and use that information to place the elements in their correct sorted positions.","Step1 :","Step 2:","Step 3:","Step 4:","Step 5:","Step 6: For i = 6,","Update outputArray[ countArray[ inputArray[6] ] \u2013 1] = inputArray[6]Also, update countArray[ inputArray[6] ]  = countArray[ inputArray[6] ]- \u2013","Step 7: For i = 5,","Update outputArray[ countArray[ inputArray[5] ] \u2013 1] = inputArray[5]Also, update countArray[ inputArray[5] ]  = countArray[ inputArray[5] ]- \u2013","Step 8: For i = 4,","Update outputArray[ countArray[ inputArray[4] ] \u2013 1] = inputArray[4]Also, update countArray[ inputArray[4] ]  = countArray[ inputArray[4] ]- \u2013","Step 9: For i = 3,","Update outputArray[ countArray[ inputArray[3] ] \u2013 1] = inputArray[3]Also, update countArray[ inputArray[3] ]  = countArray[ inputArray[3] ]- \u2013","Step 10: For i = 2,","Update outputArray[ countArray[ inputArray[2] ] \u2013 1] = inputArray[2]Also, update countArray[ inputArray[2] ]  = countArray[ inputArray[2] ]- \u2013","Step 11: For i = 1,","Update outputArray[ countArray[ inputArray[1] ] \u2013 1] = inputArray[1]Also, update countArray[ inputArray[1] ]  = countArray[ inputArray[1] ]- \u2013","Step 12: For i = 0,","Update outputArray[ countArray[ inputArray[0] ] \u2013 1] = inputArray[0]Also, update countArray[ inputArray[0] ]  = countArray[ inputArray[0] ]- \u2013","Below is the implementation of the above algorithm:"]},{"lastTimeCrawled":"2024-01-13T15:26:41.585864800","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Radix Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks","rating":300,"pageId":"26ebbb8d-902b-4f66-a5e5-93b45a43595e","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/radix-sort/?ref=outind","content":["Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. ","Rather than comparing elements directly, Radix Sort distributes the elements into buckets based on each digit\u2019s value. By repeatedly sorting the elements by their significant digits, from the least significant to the most significant, Radix Sort achieves the final sorted order.","The key idea behind Radix Sort is to exploit the concept of place value. It assumes that sorting numbers digit by digit will eventually result in a fully sorted list. Radix Sort can be performed using different variations, such as Least Significant Digit (LSD) Radix Sort or Most Significant Digit (MSD) Radix Sort.","To perform radix sort on the array [170, 45, 75, 90, 802, 24, 2, 66], we follow these steps:","How does Radix Sort Algorithm work | Step 1","Step 1: Find the largest element in the array, which is 802. It has three digits, so we will iterate three times, once for each significant place.","Step 2: Sort the elements based on the unit place digits (X=0). We use a stable sorting technique, such as counting sort, to sort the digits at each significant place.","Sorting based on the unit place:","How does Radix Sort Algorithm work | Step 2","Step 3: Sort the elements based on the tens place digits.","Sorting based on the tens place:","How does Radix Sort Algorithm work | Step 3","Step 4: Sort the elements based on the hundreds place digits.","Sorting based on the hundreds place:","How does Radix Sort Algorithm work | Step 4","Step 5: The array is now sorted in ascending order.","The final sorted array using radix sort is [2, 24, 45, 66, 75, 90, 170, 802].","How does Radix Sort Algorithm work | Step 5","Below is the implementation for the above illustrations:","Time Complexity: ","Auxiliary Space: ","Q1. Is Radix Sort preferable to Comparison based sorting algorithms like Quick-Sort? ","If we have log2n bits for every digit, the running time of Radix appears to be better than Quick Sort for a wide range of input numbers. The constant factors hidden in asymptotic notation are higher for Radix Sort and Quick-Sort uses hardware caches more effectively. Also, Radix sort uses counting sort as a subroutine and counting sort takes extra space to sort numbers.","Q2. What if the elements are in the range from 1 to n2?"]},{"lastTimeCrawled":"2024-01-13T15:26:42.213666800","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Bucket Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks","rating":283,"pageId":"0277cc91-84af-4944-ad61-3a9e49816d25","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/bucket-sort-2/?ref=outind","content":["Bucket sort is a sorting technique that involves dividing elements into various groups, or buckets. These buckets are formed by uniformly distributing the elements. Once the elements are divided into buckets, they can be sorted using any other sorting algorithm. Finally, the sorted elements are gathered together in an ordered fashion.","Create n empty buckets (Or lists) and do the following for every array element arr[i].","To apply bucket sort on the input array [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68], we follow these steps:","Step 1: Create an array of size 10, where each slot represents a bucket.","Creating Buckets for sorting","Step 2: Insert elements into the buckets from the input array based on their range.","Inserting elements into the buckets:","Inserting Array elements into respective buckets","Step 3: Sort the elements within each bucket. In this example, we use quicksort (or any stable sorting algorithm) to sort the elements within each bucket.","Sorting the elements within each bucket:","Sorting individual bucket","Step 4: Gather the elements from each bucket and put them back into the original array.","Gathering elements from each bucket:","Inserting buckets in ascending order into the resultant array","Step 5: The original array now contains the sorted elements.","The final sorted array using bucket sort for the given input is [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94].","Return the Sorted Array","Below is the implementation for the Bucket Sort:","Time Complexity: O(n2),","Auxiliary Space: O(n+k)"]},{"lastTimeCrawled":"2024-01-13T15:26:44.856371800","images":[{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-ccc84d013faba839d19d0ec320d06442_l3.png","alt":"log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-8527b67c75dc6781dfc95028e577c2d5_l3.png","alt":"n^{4/3}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-4496d830de34b88c4fe45e063b54ba8e_l3.png","alt":"n^{3/2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-57b736efe48d4e5e56fd32ce52bb2dfd_l3.png","alt":"n log n"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-7e4de21ca06ca511c64968b029fd13a9_l3.png","alt":"n^{2}"}],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Sorting Techniques \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":4585,"pageId":"3a45f172-f112-4313-a632-d4fbd0a083c3","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-sorting-algorithm/?ref=outind","content":["Sorting refers to rearrangement of a given array or list of elements according to a comparison operator on the elements. The comparison operator is used to decide the new order of elements in the respective data structure.","When we have a large amount of data, it can be difficult to deal with it, especially when it is arranged randomly. When this happens, sorting that data becomes crucial. It is necessary to sort data in order to make searching easier.","There are various sorting algorithms are used in data structures. The following two types of sorting algorithms can be broadly classified:","Sorting algorithm","The sorting algorithm is important in Computer Science because it reduces the complexity of a problem. There is a wide range of applications for these algorithms, including searching algorithms, database algorithms, divide and conquer methods, and data structure algorithms.","In the following sections, we list some important scientific applications where sorting algorithms are used  ","Below are some of the most common sorting algorithms:","Selection sort is another sorting technique in which we find the minimum element in every iteration and place it in the array beginning from the first index. Thus, a selection sort also gets divided into a sorted and unsorted subarray.","Lets consider the following array as an example: arr[] = {64, 25, 12, 22, 11}","First pass:","For the first position in the sorted array, the whole array is traversed from index 0 to 4 sequentially. The first position where 64 is stored presently, after traversing whole array it is clear that 11 is the lowest value.","Thus, replace 64 with 11. After one iteration 11, which happens to be the least value in the array, tends to appear in the first position of the sorted list.","Second Pass:","For the second position, where 25 is present, again traverse the rest of the array in a sequential manner.","After traversing, we found that 12 is the second lowest value in the array and it should appear at the second place in the array, thus swap these values.","Third Pass:","Now, for third place, where 25 is present again traverse the rest of the array and find the third least value present in the array.","While traversing, 22 came out to be the third least value and it should appear at the third place in the array, thus swap 22 with element present at third position.","Fourth pass:","Similarly, for fourth position traverse the rest of the array and find the fourth least element in the array As 25 is the 4th lowest value hence, it will place at the fourth position.","Fifth Pass:","At last the largest value present in the array automatically get placed at the last position in the arrayThe resulted array is the sorted array.","Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.","Lets consider the following array as an example: arr[]  = {5, 1, 4, 2, 8}","First Pass:","Bubble sort starts with very first two elements, comparing them to check which one is greater.( 5 1 4 2 8 ) \u2013> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1. ( 1 5 4 2 8 ) \u2013>  ( 1 4 5 2 8 ), Swap since 5 > 4 ( 1 4 5 2 8 ) \u2013>  ( 1 4 2 5 8 ), Swap since 5 > 2 ( 1 4 2 5 8 ) \u2013> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.","Second Pass:","Now, during second iteration it should look like this:","( 1 4 2 5 8 ) \u2013> ( 1 4 2 5 8 ) ( 1 4 2 5 8 ) \u2013> ( 1 2 4 5 8 ), Swap since 4 > 2 ( 1 2 4 5 8 ) \u2013> ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) \u2013>  ( 1 2 4 5 8 ) Third Pass:","Now, the array is already sorted, but our algorithm does not know if it is completed.The algorithm needs one whole pass without any swap to know it is sorted.","( 1 2 4 5 8 ) \u2013> ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) \u2013> ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) \u2013> ( 1 2 4 5 8 ) ( 1 2 4 5 8 ) \u2013> ( 1 2 4 5 8 ) ","Illustration:","Illustration of Bubble Sort","Insertion sort is a simple sorting algorithm that works similarly to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.","Consider an example: arr[]: {12, 11, 13, 5, 6}","First Pass:","Second Pass:","Third Pass:","Fourth Pass:","Illustrations:"," ","The Merge Sort algorithm is a sorting algorithm that is based on the Divide and Conquers paradigm. In this algorithm, the array is initially divided into two equal halves and then they are combined in a sorted manner.","The merge sort algorithm is an implementation of the divide and conquers technique. Thus, it gets completed in three steps:","To know the functioning of merge sort, lets consider an array arr[] = {38, 27, 43, 3, 9, 82, 10}","At first, check if the left index of array is less than the right index, if yes then calculate its mid point"," ","Now, as we already know that merge sort first divides the whole array iteratively into equal halves, unless the atomic values are achieved. Here, we see that an array of 7 items is divided into two arrays of size 4 and 3 respectively."," ","Now, again find that is left index is less than the right index for both arrays, if found yes, then again calculate mid points for both the arrays."," ","Now, further divide these two arrays into further halves, until the atomic units of the array is reached and further division is not possible."," ","After dividing the array into smallest units, start merging the elements again based on comparison of size of elementsFirstly, compare the element for each list and then combine them into another list in a sorted manner."," ","After the final merging, the list looks like this:"," ","Quicksort is a sorting algorithm based on the divide and conquer approach where an array is divided into subarrays by selecting a pivot element (element selected from the array).","To know the functioning of Quick sort, let\u2019s consider an array arr[] = {10, 80, 30, 90, 40, 50, 70}","Step1","Step2","Step3","Step 4","Step 5","Step 6","Step 7","Step 8","Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.","To understand heap sort more clearly, let\u2019s take an unsorted array and try to sort it using heap sort. Consider the array: arr[] = {4, 10, 3, 5, 1}.","Build Complete Binary Tree: Build a complete binary tree from the array.","Build complete binary tree from the array","Transform into max heap: After that, the task is to construct a tree from that unsorted array and try to convert it into max heap."," ","Make the tree a max heap","Perform heap sort: Remove the maximum element in each step (i.e., move it to the end position and remove that) and then consider the remaining elements and transform it into a max heap.","Remove 10 and perform heapify","Remove 5 and perform heapify","Remove 4 and perform heapify","The sorted array","Counting sort is a sorting technique based on keys between a specific range. It works by counting the number of objects having distinct key values (kind of hashing). Then do some arithmetic to calculate the position of each object in the output sequence. ","Consider the array: arr[] = {1, 4, 1, 2, 7, 5, 2}."," "," ","Radix sort is a non-comparative sorting algorithm that is used to sort the data in lexicographical (dictionary) order.","It uses counting sort as a subroutine, to sort an array of integer digit by digit and array of strings character by character.","Bucket Sort is a sorting algorithm that divides the unsorted array elements into several groups called buckets. Each bucket is then sorted by using any of the suitable sorting algorithms or recursively applying the same bucket algorithm.","Finally, the sorted buckets are combined to form a final sorted array.","Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h-sorted if all sublists of every h\u2019th element are sorted.","Timsort is a hybrid sorting algorithm. It is used to give optimal results while dealing with real-world data.","Timsort has been derived from Insertion Sort and Binary Merge Sort. At first, the array is stored into smaller chunks of data known as runs. These runs are sorted using insertion sort and then merged using the merge sort.","Comb Sort is mainly an improvement over Bubble Sort. Bubble sort always compares adjacent values. So all inversions are removed one by one. Comb Sort improves on Bubble Sort by using a gap of the size of more than 1. The gap starts with a large value and shrinks by a factor of 1.3 in every iteration until it reaches the value 1. Thus Comb Sort removes more than one inversion count with one swap and performs better than Bubble Sort.","Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements and the number of possible key values are approximately the same.","Cycle sort is an in-place sorting Algorithm, unstable sorting algorithm, and a comparison sort that is theoretically optimal in terms of the total number of writes to the original array. ","Cocktail Sort is a variation of Bubble sort. The Bubble sort algorithm always traverses elements from left and moves the largest element to its correct position in the first iteration and second-largest in the second iteration and so on. Cocktail Sort traverses through a given array in both directions alternatively. Cocktail sort does not go through the unnecessary iteration making it efficient for large arrays.","Cocktail sorts break down barriers that limit bubble sorts from being efficient enough on large arrays by not allowing them to go through unnecessary iterations on one specific region (or cluster) before moving onto another section of an array.","Strand sort is a recursive sorting algorithm that sorts items of a list into increasing order. It has O(n²) worst time complexity which occurs when the input list is reverse sorted. It has a best case time complexity of O(n) which occurs when the input is a list that is already sorted.","Bitonic Sort is a classic parallel algorithm for sorting.","Stooge Sort is a recursive sorting algorithm. It is not much efficient but an interesting sorting algorithm. It generally divides the array into two overlapping parts (2/3 each). After that it performs sorting in first 2/3 part and then it performs sorting in last 2/3 part. And then, sorting is done on first 2/3 part to ensure that the array is sorted.","The key idea is that sorting the overlapping part twice exchanges the elements between the other two sections accordingly.","This is not a new sorting algorithm, but an idea when we need to avoid swapping of large objects or need to access elements of a large array in both original and sorted orders.A common sorting task is to sort elements of an array using a sorting algorithm like Quick Sort, Bubble Sort.. etc, but there may be times when we need to keep the actual array intact and use a \u201ctagged\u201d array to store the correct positioning of the array when it is sorted. When we want to access elements in a sorted way, we can use this \u201ctagged\u201d array.","Tree sort is a sorting algorithm that is based on Binary Search Tree data structure. It first creates a binary search tree from the elements of the input list or array and then performs an in-order traversal on the created binary search tree to get the elements in sorted order. ","Cartesian Sort is an Adaptive Sorting as it sorts the data faster if data is partially sorted. In fact, there are very few sorting algorithms that make use of this fact. For example consider the array {5, 10, 40, 30, 28}. The input data is partially sorted too as only one swap between \u201c40\u201d and \u201c28\u201d results in a completely sorted order. ","This is basically a variation of bubble-sort. This algorithm is divided into two phases- Odd and Even Phase. The algorithm runs until the array elements are sorted and in each iteration two phases occurs- Odd and Even Phases.In the odd phase, we perform a bubble sort on odd indexed elements and in the even phase, we perform a bubble sort on even indexed elements.","Merge sort involves recursively splitting the array into 2 parts, sorting, and finally merging them. A variant of merge sort is called 3-way merge sort where instead of splitting the array into 2 parts we split it into 3 parts. Merge sort recursively breaks down the arrays to subarrays of size half. Similarly, the 3-way Merge sort breaks down the arrays to subarrays of size one-third. ","Gnome Sort also called Stupid sort is based on the concept of a Garden Gnome sorting his flower pots. A garden gnome sorts the flower pots by the following method-  ","Cocktail Sort is a variation of Bubble sort. The Bubble sort algorithm always traverses elements from the left and moves the largest element to its correct position in the first iteration and the second-largest in the second iteration and so on. Cocktail Sort traverses through a given array in both directions alternatively. Cocktail sort does not go through the unnecessary iteration making it efficient for large arrays.","Cocktail sorts break down barriers that limit bubble sorts from being efficient enough on large arrays by not allowing them to go through unnecessary iterations on one specific region (or cluster) before moving onto another section of an array.","H"]},{"lastTimeCrawled":"2024-01-13T15:26:45.774022900","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Greedy Algorithm - Data Structures and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"8c892727-59bb-4b71-ae38-030b2b3222ed","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/?ref=outind","content":["Greedy Algorithm is defined as a method for solving optimization problems by taking decisions that result in the most evident and immediate benefit irrespective of the final outcome. It works for cases where minimization or maximization leads to the required solution.","For a problem to be solved using the Greedy approach, it must follow a few major characteristics:","Introduction to Greedy Algorithm \u2013 Data Structures and Algorithm Tutorials","The greedy algorithm is a method used in optimization problems where the goal is to make the locally optimal choice at each stage with the hope of finding a global optimum. It is called \u201cgreedy\u201d because it tries to find the best solution by making the best choice at each step, without considering future steps or the consequences of the current decision.","Some common use cases for the greedy algorithm include:","It\u2019s important to note that not all optimization problems can be solved by a greedy algorithm, and there are cases where the greedy approach can lead to suboptimal solutions. However, in many cases, the greedy algorithm provides a good approximation to the optimal solution and is a useful tool for solving optimization problems quickly and efficiently.","The greedy approach has a few tradeoffs, which may make it suitable for optimization. One prominent reason is to achieve the most feasible solution immediately. In the activity selection problem (Explained below), if more activities can be done before finishing the current activity, these activities can be performed within the same time.  Another reason is to divide a problem recursively based on a condition, with no need to combine all the solutions. In the activity selection problem, the \u201crecursive division\u201d step is achieved by scanning a list of items only once and considering certain activities.","Some Famous problems that exhibit Optimal substructure property and can be solved using Greedy approach are \u2013","Greedily choose the jobs with maximum profit first, by sorting the jobs in decreasing order of their profit. This would help to maximize the total profit as choosing the job with maximum profit for every time slot will eventually maximize the total profit","It starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST. ","When the choice to apply the greedy method is made without conducting a thorough examination, the decision to utilize it can be somewhat difficult and occasionally even result in failure. In some cases taking the local best choice may lead to losing the global optimal solution. ","For example: ","Graph with weighted vertices","Greedy Approach fails","Correct Approach","Thus to use Greedy algorithm the problem must not contain overlapping subproblems.","Greedy algorithm and Dynamic programming are two of the most widely used algorithm paradigms for solving complex programming problems, While Greedy approach works for problems where local optimal choice leads to global optimal solution Dynamic Programming works for problems having overlapping subproblems structure where answer to a subproblem is needed for solving several other subproblems. Detailed differences are given in the table below: ","Feature","Feasibility ","Optimality","Recursion","Memoization","Time complexity","Fashion","Example","Some of the popular problems on the Greedy Approach that are widely asked in interviews are:"]},{"lastTimeCrawled":"2024-01-13T15:26:48.003864","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Dynamic Programming (DP) Tutorial with Problems - GeeksforGeeks","rating":332,"pageId":"ff9703ad-56f4-4cca-8aed-c03dda547180","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials/?ref=outind","content":["Dynamic Programming (DP) is defined as a technique that solves some particular type of problems in Polynomial Time. Dynamic Programming solutions are faster than the exponential brute method and can be easily proved their correctness.","Dynamic Programming is mainly an optimization over plain recursion. Wherever we see a recursive solution that has repeated calls for the same inputs, we can optimize it using Dynamic Programming. The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization reduces time complexities from exponential to polynomial.","Introduction to Dynamic Programming \u2013 Data Structures and Algorithm Tutorials","Dynamic programming works on following principles: ","Applications:","Dynamic programming is used to solve optimization problems. It is used to solve many real-life problems such as,","(i) Make a change problem"," (ii) Knapsack problem","(iii) Optimal binary search tree","Break down the given problem in order to begin solving it. If you see that the problem has already been solved, return the saved answer. If it hasn\u2019t been solved, solve it and save it. This is usually easy to think of and very intuitive, This is referred to as Memoization.","Analyze the problem and see in what order the subproblems are solved, and work your way up from the trivial subproblem to the given problem. This process ensures that the subproblems are solved before the main problem. This is referred to as Dynamic Programming.","Types of the approach of dynamic programming algorithm","There are two different ways to store the values so that the values of a sub-problem can be reused. Here, will discuss two patterns of solving dynamic programming (DP) problems: ","Before getting to the definitions of the above two terms consider the following statements:","Both versions say the same thing, the difference simply lies in the way of conveying the message and that\u2019s exactly what Bottom-Up and Top-Down DP do. Version 1 can be related to Bottom-Up DP and Version-2 can be related to Top-Down DP.","To dynamically solve a problem, we need to check two necessary conditions: ","N-th Fibonacci Series as Overlapping Subproblems","Steps to solve a Dynamic programming problem:","Problems with dynamic programming are mostly concerned with the state and its transition. The most fundamental phase must be carried out with extreme care because the state transition depends on the state definition you select.","State:","A state is a collection of characteristics that can be used to specifically describe a given position or standing in a given challenge. To minimise state space, this set of parameters has to be as compact as feasible.","The hardest part of a Dynamic Programming challenge is this step, which calls for a lot of intuition, observation, and training.","Example:","Given 3 numbers {1, 3, 5}, the task is to tell the total number of ways we can form a number N using the sum of the given three numbers. (allowing repetitions and different arrangements).","The total number of ways to form 6 is: 81+1+1+1+1+11+1+1+31+1+3+11+3+1+13+1+1+13+31+55+1","Following are the steps to solve the problem:","As we can only use 1, 3, or 5 to form a given number N. Let us assume that we know the result for N = 1, 2, 3, 4, 5, 6 ","Let us say we know the result for:state (n = 1), state (n = 2), state (n = 3) \u2026\u2026\u2026 state (n = 6) Now, we wish to know the result of the state (n = 7). See, we can only add 1, 3, and 5. Now we can get a sum total of 7 in the following 3 ways:","1) Adding 1 to all possible combinations of state (n = 6) Eg: [ (1+1+1+1+1+1) + 1] [ (1+1+1+3) + 1] [ (1+1+3+1) + 1] [ (1+3+1+1) + 1] [ (3+1+1+1) + 1] [ (3+3) + 1] [ (1+5) + 1] [ (5+1) + 1]","2) Adding 3 to all possible combinations of state (n = 4);[(1+1+1+1) + 3] [(1+3) + 3] [(3+1) + 3]","3) Adding 5 to all possible combinations of state(n = 2) [ (1+1) + 5]","(Note how it sufficient to add only on the right-side \u2013 all the add-from-left-side cases are covered, either in the same state, or another, e.g. [ 1+(1+1+1+3)]  is not needed in state (n=6) because it\u2019s covered by state (n = 4) [(1+1+1+1) + 3])","Now, think carefully and satisfy yourself that the above three cases are covering all possible ways to form a sum total of 7;Therefore, we can say that result for state(7) = state (6) + state (4) + state (2) ORstate(7) = state (7-1) + state (7-3) + state (7-5)In general, state(n) = state(n-1) + state(n-3) + state(n-5)","Below is the implementation for the above approach:","Time Complexity: O(3n), As at every stage we need to take three decisions and the height of the tree will be of the order of n.Auxiliary Space: O(n), The extra space is used due to the recursion call stack.","The above code seems exponential as it is calculating the same state again and again. So, we just need to add memoization.","The simplest portion of a solution based on dynamic programming is this. Simply storing the state solution will allow us to access it from memory the next time that state is needed.","Adding memoization to the above code:","Time Complexity: O(n), As we just need to make 3n function calls and there will be no repetitive calculations as we are returning previously calculated results.Auxiliary Space: O(n), The extra space is used due to the recursion call stack.","Problem: Let\u2019s find the Fibonacci sequence up to the nth term. A Fibonacci series is the sequence of numbers in which each number is the sum of the two preceding ones. For example, 0, 1, 1, 2, 3, and so on. Here, each number is the sum of the two preceding numbers.","Naive Approach: The basic way to find the nth Fibonacci number is to use recursion.","Below is the implementation for the above approach:","Complexity Analysis: ","Time Complexity: O(2n)","Efficient approach: As it is a very terrible complexity(Exponential), thus we need to optimize it with an efficient method. (Memoization)","Let\u2019s look at the example below for finding the 5th Fibonacci number.","Representation of 5th Fibonacci number","Observations:","Way to memoize: To achieve this in our example we will simply take an answer array initialized to -1. As we make a recursive call, we will first check if the value stored in the answer array corresponding to that position is -1. The value -1 indicates that we haven\u2019t calculated it yet and have to recursively compute it. The output must be stored in the answer array so that, next time, if the same value is encountered, it can be directly used from the answer array.   ","Now in this process of memoization, considering the above Fibonacci numbers example, it can be observed that the total number of unique calls will be at most (n + 1) only.","Below is the implementation for the above approach:","Complexity analysis:","Optimized approach: Following a bottom-up approach to reach the desired index. This approach of converting recursion into iteration is known as Dynamic programming(DP).","Observations:","Below is the implementation for the above approach:","Complexity analysis: ","Optimization of above method","Feature","Feasibility ","Optimality","Recursion","Memoization                                   ","    Time        complexity                    ","Fashion","Example","S. No.","Problem","Practice link","1","Min Cost Path ","solve","2","Subset Sum Problem","solve","3","Knapsack problem","solve","4","Coin Change ","solve","5","Edit Distance ","solve","6","Cutting a Rod","solve","7","Subset Sum Problem","solve","8","Longest Common Subsequence","solve","9","Matrix chain multiplication","solve","10","Count Distinct Subsequences","solve","11","Prefix Sum of Matrix (Or 2D Array)","solve ","12","solve","Dynamic programming and recursion are things completely different. While dynamic programming can use recursion techniques, recursion itself doesn\u2019t have anything similar to dynamic programming. . Dynamic programming involves breaking down a problem into smaller subproblems, storing the solutions to these subproblems to avoid redundant computation, and using these solutions to construct the overall solution. Recursion, on the other hand, is a technique for solving problems by breaking them down into smaller subproblems and solving them recursively.","Dynamic Programming (DP) is a technique that solves some particular type of problems in Polynomial Time. Dynamic Programming solutions are faster than the exponential brute method and can be easily proved their correctness. Dynamic programming works by breaking down a problem into smaller subproblems, solving each subproblem independently, and using the solutions to these subproblems to construct the overall solution. The solutions to the subproblems are stored in a table or array (memoization) or in a bottom-up manner (tabulation) to avoid redundant computation.","Greedy Algorithms are similar to dynamic programming in the sense that they are both tools for optimization. Both dynamic programming and greedy algorithms are used for optimization problems. However, while dynamic programming breaks down a problem into smaller subproblems and solves them independently, greedy algorithms make a locally optimal choice at each step with the hope of finding a globally optimal solution.","You can solve subproblems faster by using dynamic programming, which is nothing more than recursion and memoization, thereby reducing the complexity of your code and making it faster. Following are the basic points:","Dynamic programming has the advantage of being able to find both a local and a global optimal solution. Additionally, practical experience can be exploited to benefit from dynamic programming\u2019s better efficiency. However, there isn\u2019t a single, accepted paradigm for dynamic programming, and other conditions could show up as the problem is being solved. Dynamic programming algorithms are guaranteed to find the optimal solution among a set of possible solutions, provided that the problem satisfies the principle of optimality. The solutions to subproblems can be stored in a table, which can be reused for similar problems. Dynamic programming can be applied to a wide range of problems, including optimization, sequence alignment, and resource allocation.","In conclusion, dynamic programming is a powerful problem-solving technique that is used for optimization problems. Dynamic programming is a superior form of recursion that overcomes its limitations. It involves breaking down a problem into smaller subproblems, solving each subproblem independently, and using the solutions to these subproblems to construct the overall solution. The key characteristics of a dynamic programming algorithm include overlapping subproblems, optimal substructure, memoization or tabulation, and the use of either iterative or recursive methods.","Dynamic programming has several advantages over other problem-solving techniques, including efficiency, simplicity, flexibility, optimality, clarity, and code reusability. It is not just recursion, although it can be implemented using a recursive algorithm. Dynamic programming is different from greedy algorithms in that it breaks down the problem into smaller subproblems, solves each subproblem independently, and uses the solutions to the subproblems to construct the overall solution.","The basics of dynamic programming include breaking down a problem into smaller subproblems, solving each subproblem independently, storing the solutions to subproblems to avoid redundant computation, using the solutions to the subproblems to construct the overall solution and using the principle of optimality to ensure that the solution is optimal.  However, DP can occasionally be challenging to comprehend, making it a well-liked option for coding interviews. Understanding how DP functions work can be useful to everyone, whether they are a professional or a student getting ready for the placements. ","Overall, dynamic programming is a valuable tool for solving complex optimization problems and can lead to more efficient and effective solutions."]},{"lastTimeCrawled":"2024-01-13T15:26:49.746056600","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Pattern Searching - Data Structure and Algorithm Tutorial - GeeksforGeeks","rating":332,"pageId":"475f2d31-6b1d-49d1-8334-5d88173dcfb3","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-pattern-searching-data-structure-and-algorithm-tutorial/?ref=outind","content":["Pattern searching is an algorithm that involves searching for patterns such as strings, words, images, etc.","We use certain algorithms to do the search process. The complexity of pattern searching varies from algorithm to algorithm. They are very useful when performing a search in a database. The Pattern Searching algorithm is useful for finding patterns in substrings of larger strings. This process can be accomplished using a variety of algorithms that we are going to discuss in this blog. ","Introduction to Pattern Searching \u2013 Data Structure and Algorithm Tutorial","Naive pattern searching is the simplest method among other pattern-searching algorithms. It checks for all characters of the main string to the pattern. This algorithm is helpful for smaller texts. It does not need any pre-processing phases. We can find the substring by checking once for the string. It also does not occupy extra space to perform the operation.","Compare text characters with pattern characters","The time complexity of Naive Pattern Search method is O(m*n). The m is the size of pattern and n is the size of the main string.","Time Complexity: O(N*M)Auxiliary Space: O(1)","KMP algorithm is used to find a \u201cPattern\u201d in a \u201cText\u201d. This algorithm compares character by character from left to right. But whenever a mismatch occurs, it uses a preprocessed table called \u201cPrefix Table\u201d to skip characters comparison while matching. Sometimes prefix table is also known as LPS Table. Here LPS stands for \u201cLongest proper Prefix which is also Suffix\u201d.","We use the LPS table to decide how many characters are to be skipped for comparison when a mismatch has occurred.When a mismatch occurs, check the LPS value of the previous character of the mismatched character in the pattern. If it is \u20180\u2019 then start comparing the first character of the pattern with the next character to the mismatched character in the text. If it is not \u20180\u2019 then start comparing the character which is at an index value equal to the LPS value of the previous character to the mismatched character in pattern with the mismatched character in the Text. ","Example of KMP algorithm","Compare first character of pattern with first character of text from left to right","Compare first character of pattern with next character of text","Compare pattern[0] and pattern[1] values","Compare pattern[0] with next characters in text.","Compare pattern[2] with mismatched characters in text.","Let\u2019s take a look on working example of KMP Algorithm to find a Pattern in a Text.","LPS table","Define variables","Compare A with B","Compare A with C","Compare A with D","Compare A with A","Compare B with B","Compare C with D","Compare A with D","Implementation of the KMP algorithm:","Time complexity: O(n + m)Auxiliary Space: O(M)","Rabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string-matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then perform the comparison.","Rabin-Karp compares a string\u2019s hash values, rather than the strings themselves. For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.","Example of Rabin Karp","Below is the implementation of the Rabin-Karp algorithm.","Time Complexity:","Space Complexity : ","          The space complexity of the Rabin-Karp algorithm is O(1), which means that it is a constant amount of memory that is required, regardless of the size of the input text and pattern. This is because the algorithm only needs to store a few variables that are updated as the algorithm progresses through the text and pattern. Specifically, the algorithm needs to store the hash value of the pattern, the hash value of the current window in the text, and a few loop counters and temporary variables. Since the size of these variables is fixed, the space complexity is constant.","This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it\u2019s prefix. ","For a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself.","Example:","Index            0   1   2   3   4   5   6   7   8   9  10  11 Text             a   a   b   c   a   a   b   x   a   a   a   zZ values         X   1   0   0   3   1   0   0   2   2   1   0 ","A Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at current index. The time complexity of this solution is O(n2).","We can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max Rsuch that [L, R] is prefix substring (substring which is also a prefix. ","Steps for maintaining this interval are as follows \u2013 ","Construction of Z array","Below is the implementation of the Z algorithm:","Time Complexity: O(m+n), where m is length of pattern and n is length of text.Auxiliary Space: O(m+n)","Aho-Corasick Algorithm finds all words in O(n + m + z) time where z is the total number of occurrences of words in text. The Aho\u2013Corasick string matching algorithm formed the basis of the original Unix command \u201cfgrep\u201d. ","Preprocessing: Build an automaton of all words in arr[] The automaton has mainly three functions:","Go To:  This function simply follows edges of Trie of all words in arr[]. It is represented as 2D array g[][] where we store next state for current state and character.","Failure: This function stores all edges that are followed when current character doesn\u2019t have edge in Trie.It is represented as1D array f[] where we store next state for current state.","Output: Stores indexes of all words that end at current state. It is represented as 1D  array o[] where we store indices of all matching words as a bitmap for current state.","Matching: Traverse the given text over built automaton to find all matching words.Preprocessing:","Preprocessing: We first Build a Trie (or Keyword Tree) of all words. "," Build a Trie (or Keyword Tree) of all words.","Fills entries in goto g[][] and output o[]","Go to:  We build Trie. And for all characters which don\u2019t have an edge at the root, we add an edge back to root.Failure:  For a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.Output: For a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure.","Below is the implementation of the Aho-Corasick Algorithm:","Time Complexity: O(n + l + z), where \u2018n\u2019 is the length of the text, \u2018l\u2019 is the length of keywords, and \u2018z\u2019 is the number of matches.Auxiliary Space: O(l * q), where \u2018q\u2019 is the length of the alphabet since that is the maximum number of children a node can have.","H"]},{"lastTimeCrawled":"2024-01-13T15:26:51.721442800","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Recursion - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":316,"pageId":"002e4589-1cb1-4160-b424-1ad2f4e92e1e","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-recursion-data-structure-and-algorithm-tutorials/?ref=outind","content":["What is Recursion? The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily. Examples of such problems are Towers of Hanoi (TOH), Inorder/Preorder/Postorder Tree Traversals, DFS of Graph, etc. A recursive function solves a particular problem by calling a copy of itself and solving smaller subproblems of the original problems. Many more recursive calls can be generated as and when required. It is essential to know that we should provide a certain case in order to terminate this recursion process. So we can say that every time the function calls itself with a simpler version of the original problem.","Need of Recursion","Recursion is an amazing technique with the help of which we can reduce the length of our code and make it easier to read and write. It has certain advantages over the iteration technique which will be discussed later. A task that can be defined with its similar subtask, recursion is one of the best solutions for it. For example; The Factorial of a number.","Properties of Recursion:","A Mathematical Interpretation","Let us consider a problem that a programmer has to determine the sum of first n natural numbers, there are several ways of doing that but the simplest approach is simply to add the numbers starting from 1 to n. So the function simply looks like this,","approach(1) \u2013 Simply adding one by one","f(n) = 1 + 2 + 3 +\u2026\u2026..+ n","but there is another mathematical approach of representing this,","approach(2) \u2013 Recursive adding ","f(n) = 1                  n=1","f(n) = n + f(n-1)    n>1","There is a simple difference between the approach (1) and approach(2) and that is in approach(2) the function \u201c f( ) \u201d itself is being called inside the function, so this phenomenon is named recursion, and the function containing recursion is called recursive function, at the end, this is a great tool in the hand of the programmers to code some problems in a lot easier and efficient way.","How are recursive functions stored in memory?","Recursion uses more memory, because the recursive function adds to the stack with each recursive call, and keeps the values there until the call is finished. The recursive function uses LIFO (LAST IN FIRST OUT) Structure just like the stack data structure. https://www.geeksforgeeks.org/stack-data-structure/ ","What is the base condition in recursion? In the recursive program, the solution to the base case is provided and the solution to the bigger problem is expressed in terms of smaller problems.  ","In the above example, the base case for n < = 1 is defined and the larger value of a number can be solved by converting to a smaller one till the base case is reached.","How a particular problem is solved using recursion? The idea is to represent a problem in terms of one or more smaller problems, and add one or more base conditions that stop the recursion. For example, we compute factorial n if we know the factorial of (n-1). The base case for factorial would be n = 0. We return 1 when n = 0. ","Why Stack Overflow error occurs in recursion? If the base case is not reached or not defined, then the stack overflow problem may arise. Let us take an example to understand this.","If fact(10) is called, it will call fact(9), fact(8), fact(7), and so on but the number will never reach 100. So, the base case is not reached. If the memory is exhausted by these functions on the stack, it will cause a stack overflow error. ","What is the difference between direct and indirect recursion? A function fun is called direct recursive if it calls the same function fun. A function fun is called indirect recursive if it calls another function say fun_new and fun_new calls fun directly or indirectly. The difference between direct and indirect recursion has been illustrated in Table 1. ","What is the difference between tailed and non-tailed recursion? A recursive function is tail recursive when a recursive call is the last thing executed by the function. Please refer tail recursion article for details. ","How memory is allocated to different function calls in recursion? When any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for a called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues.Let us take the example of how recursion works by taking a simple function. ","Time Complexity: O(1)Auxiliary Space: O(1)","When printFun(3) is called from main(), memory is allocated to printFun(3) and a local variable test is initialized to 3 and statement 1 to 4 are pushed on the stack as shown in below diagram. It first prints \u20183\u2019. In statement 2, printFun(2) is called and memory is allocated to printFun(2) and a local variable test is initialized to 2 and statement 1 to 4 are pushed into the stack. Similarly, printFun(2) calls printFun(1) and printFun(1) calls printFun(0). printFun(0) goes to if statement and it return to printFun(1). The remaining statements of printFun(1) are executed and it returns to printFun(2) and so on. In the output, values from 3 to 1 are printed and then 1 to 3 are printed. The memory stack has been shown in below diagram.","Recursion VS Iteration","Now, let\u2019s discuss a few practical problems which can be solved by using recursion and understand its basic working. For basic understanding please read the following articles. Basic understanding of Recursion.Problem 1: Write a program and recurrence relation to find the Fibonacci series of n where n>2 . Mathematical Equation:  ","Recurrence Relation: ","Recursive program: ","Implementation: ","Time Complexity: O(2n)Auxiliary Space: O(n)","Here is the recursive tree for input 5 which shows a clear picture of how a big problem can be solved into smaller ones. fib(n) is a Fibonacci function. The time complexity of the given program can depend on the function call. ","fib(n) -> level CBT (UB) -> 2^n-1 nodes -> 2^n function call -> 2^n*O(1) -> T(n) = O(2^n)  ","For Best Case. ","Working: ","Problem 2: Write a program and recurrence relation to find the Factorial of n where n>2 . Mathematical Equation: ","Recurrence Relation: ","Recursive Program: Input: n = 5 Output: factorial of 5 is: 120Implementation: ","Time complexity: O(n)Auxiliary Space: O(n)","Working:  ","Diagram of factorial Recursion function for user input 5.","Recursion is a powerful technique that has many applications in computer science and programming. Here are some of the common applications of recursion:","These are just a few examples of the many applications of recursion in computer science and programming. Recursion is a versatile and powerful tool that can be used to solve many different types of problems.","Recursion is a programming technique that involves a function calling itself. It can be a powerful tool for solving complex problems, but it also requires careful implementation to avoid infinite loops and stack overflows. ","In this example, we define a function called factorial that takes an integer n as input. The function uses recursion to compute the factorial of n (i.e., the product of all positive integers up to n).","The factorial function first checks if n is 0 or 1, which are the base cases. If n is 0 or 1, the function returns 1, since 0! and 1! are both 1.","If n is greater than 1, the function enters the recursive case. It calls itself with n-1 as the argument and multiplies the result by n. This computes n! by recursively computing (n-1)!.","It\u2019s important to note that recursion can be inefficient and lead to stack overflows if not used carefully. Each function call adds a new frame to the call stack, which can cause the stack to grow too large if the recursion is too deep. In addition, recursion can make the code more difficult to understand and debug, since it requires thinking about multiple levels of function calls.","However, recursion can also be a powerful tool for solving complex problems, particularly those that involve breaking a problem down into smaller subproblems. When used correctly, recursion can make the code more elegant and easier to read.","What are the disadvantages of recursive programming over iterative programming? Note that both recursive and iterative programs have the same problem-solving powers, i.e., every recursive program can be written iteratively and vice versa is also true. The recursive program has greater space requirements than the iterative program as all functions will remain in the stack until the base case is reached. It also has greater time requirements because of function calls and returns overhead.","Moreover, due to the smaller length of code, the codes are difficult to understand and hence extra care has to be practiced while writing the code. The computer may run out of memory if the recursive calls are not properly checked.","What are the advantages of recursive programming over iterative programming? Recursion provides a clean and simple way to write code. Some problems are inherently recursive like tree traversals, Tower of Hanoi, etc. For such problems, it is preferred to write recursive code. We can write such codes also iteratively with the help of a stack data structure. For example refer Inorder Tree Traversal without Recursion, Iterative Tower of Hanoi.","Summary of Recursion:","Output based practice problems for beginners: Practice Questions for Recursion | Set 1 Practice Questions for Recursion | Set 2 Practice Questions for Recursion | Set 3 Practice Questions for Recursion | Set 4 Practice Questions for Recursion | Set 5 Practice Questions for Recursion | Set 6 Practice Questions for Recursion | Set 7Quiz on Recursion Coding Practice on Recursion: All Articles on Recursion Recursive Practice Problems with Solutions","S"]},{"lastTimeCrawled":"2024-01-13T15:26:53.106915500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Backtracking - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":283,"pageId":"617185d1-c12f-42b3-bd8f-788679074580","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-backtracking-data-structure-and-algorithm-tutorials/?ref=outind","content":["Backtracking is like trying different paths, and when you hit a dead end, you backtrack to the last choice and try a different route. In this article, we\u2019ll explore the basics of backtracking, how it works, and how it can help solve all sorts of challenging problems. It\u2019s like a method for finding the right way through a complex choices.","Table of Content","Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.","Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.","Introduction to Backtracking","Problems associated with backtracking can be categorized into 3 categories:","As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:","As shown in the image, \u201cIS\u201d  represents the Initial State where the recursion call starts to find a valid solution. C : it represents different Checkpoints for recursive calls","TN: it represents the Terminal Nodes where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state.","At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image TN1\u2026TN5 are the terminal node where the solution is not acceptable, while TN6 is the state where we found a valid solution.","The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint.","Generally every constraint satisfaction problem can be solved using backtracking but, Is it optimal to use backtracking every time? Turns out NO, there are a vast number of problem that can be solved using Greedy or Dynamic programming in logarithmic or polynomial time complexity which is far better than exponential complexity of Backtracking. However many problems still exists that can only be solved using Backtracking.","To understand whether a problem is Backtracking based or not, let us take a simple problem:Problem: Imagine you have 3 closed boxes, among which 2 are empty and 1 has a gold coin. Your task is to get the gold coin.","Why dynamic programming fails to solve this question: Does opening or closing one box has any effect on the other box? Turns out NO, each and every box is independent of each other and opening/closing state of one box can not determine the transition for other boxes. Hence DP fails.","Why greedy fails to solve this question: Greedy algorithm chooses a local maxima in order to get global maxima, but in this problem each and every box has equal probability of having a gold coin i.e 1/3 hence there is no criteria to make a greedy choice.","Why Backtracking works: As discussed already, backtracking algorithm is simply brute forcing each and every choice, hence we can one by one choose every box to find the gold coin, If a box is found empty we can close it back which acts as a Backtracking step.","Technically, for backtracking problems:","The best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode:","void FIND_SOLUTIONS( parameters):","if (valid solution):","store the solution","Return","for (all choice):","if (valid choice):","APPLY (choice)","FIND_SOLUTIONS (parameters)","BACKTRACK (remove choice)","Return","Since backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities:","These complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly.","Recursion and Backtracking are related concepts in computer science and programming, but they are not the same thing. Let\u2019s explore the key differences between them:","Recursion","Backtracking","Recursion does not always need backtracking","Backtracking always uses recursion to solve problems","Solving problems by breaking them into smaller, similar subproblems and solving them recursively.","Solving problems with multiple choices and exploring options systematically, backtracking when needed.","Controlled by function calls and call stack.","Managed explicitly with loops and state.","Applications of Recursion: Tree and Graph Traversal, Towers of Hanoi, Divide and Conquer Algorithms, Merge Sort, Quick Sort, and Binary Search.","Application of Backtracking: N Queen problem, Rat in a Maze problem, Knight\u2019s Tour Problem, Sudoku solver, and Graph coloring problems.","For more practice problems: click here"]},{"lastTimeCrawled":"2024-01-13T15:26:54.728775700","images":[{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-499c9ee0d66608aa1be971ae015016d7_l3.png","alt":"3n^{log_{2}^{3}}\\approx 3n^{1.585}"},{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-781e5f5830bcfa6323b2bef0699f7e23_l3.png","alt":"n^{\\log_23}                 "}],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Divide and Conquer Algorithm - Data Structure and Algorithm Tutorials - GeeksforGeeks","rating":294,"pageId":"55670ad6-02ad-45b7-a4c3-2a12977f8635","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm-data-structure-and-algorithm-tutorials/?ref=outind","content":["In this article, we are going to discuss how Divide and Conquer technique is helpful and how we can solve the problem with the DAC technique approach. In this section, we will discuss the following topics. ","Divide And Conquer This technique can be divided into the following three parts:","The following are some standard algorithms that follow Divide and Conquer algorithm.  ","single-digit multiplications in general (and exactly when n is a power of 2). It is, therefore, faster than the classical algorithm, which requires n2 single-digit products. If n = 210 = 1024, in particular, the exact counts are 310 = 59, 049 and (210)2 = 1, 048, 576, respectively.","What does not qualifies as Divide and Conquer:","Binary Search is a searching algorithm. In each step, the algorithm compares the input element x with the value of the middle element in the array. If the values match, return the index of the middle. Otherwise, if x is less than the middle element, then the algorithm recurs for the left side of the middle element, else recurs for the right side of the middle element. Contrary to popular belief, this is not an example of Divide and Conquer because there is only one sub-problem in each step (Divide and conquer requires that there must be two or more sub-problems) and hence this is a case of Decrease and Conquer.","Divide And Conquer algorithm :  ","Recurrence Relation for DAC algorithm : This is a recurrence relation for the above program. ","Example: To find the maximum and minimum element in a given array. ","Approach: To find the maximum and minimum element from a given array is an application for divide and conquer. In this problem, we will find the maximum and minimum elements in a given array. In this problem, we are using a divide and conquer approach(DAC) which has three steps divide, conquer and combine.","For Maximum: In this problem, we are using the recursive approach to find the maximum where we will see that only two elements are left and then we can easily use condition i.e. if(a[index]>a[index+1].)In a program line a[index] and a[index+1])condition will ensure only two elements in left.","if(index >= l-2) { if(a[index]>a[index+1]) { // (a[index] // Now, we can say that the last element will be maximum in a given array. } else { //(a[index+1] // Now, we can say that last element will be maximum in a given array. }}","In the above condition, we have checked the left side condition to find out the maximum. Now, we will see the right side condition to find the maximum. Recursive function to check the right side at the current index of an array.","max = DAC_Max(a, index+1, l); // Recursive call","Now, we will compare the condition and check the right side at the current index of a given array. In the given program, we are going to implement this logic to check the condition on the right side at the current index.","// Right element will be maximum. if(a[index]>max) return a[index];// max will be maximum element in a given array. else return max; }  ","For Minimum: In this problem, we are going to implement the recursive approach to find the minimum no. in a given array. ","int DAC_Min(int a[], int index, int l) //Recursive call function to find the minimum no. in a given array.if(index >= l-2) // to check the condition that there will be two-element in the left then we can easily find the minimum element in a given array. { // here we will check the condition if(a[index]<a[index+1]) return a[index]; else return a[index+1]; }","Now, we will check the condition on the right side in a given array. ","// Recursive call for the right side in the given array. min = DAC_Min(a, index+1, l);  ","Now, we will check the condition to find the minimum on the right side.","// Right element will be minimum if(a[index]<min) return a[index]; // Here min will be minimum in a given array. else return min;  ","Implementation:  ","Time Complexity:The time complexity of the divide and conquer algorithm to find the maximum and minimum element in an array is O(n). This is because each time we divide the array in half, so we will have a total of log(n) divisions. In each division, we compare two elements to find the maximum and minimum element, which takes constant time. Therefore, the total time complexity is O(n*log(n)).","Space Complexity:The space complexity of the divide and conquer algorithm to find the maximum and minimum element in an array is O(log(n)). This is because we are using recursion to divide the array into smaller parts, and each recursive call takes up space on the call stack. The maximum depth of the recursion tree is log(n), which is the number of times we can divide the array in half. Therefore, the space complexity is O(log(n)).","Divide and Conquer (D & C) vs Dynamic Programming (DP) Both paradigms (D & C and DP) divide the given problem into subproblems and solve subproblems. How do choose one of them for a given problem? Divide and Conquer should be used when the same subproblems are not evaluated many times. Otherwise Dynamic Programming or Memoization should be used. For example, Quicksort is a Divide and Conquer algorithm, we never evaluate the same subproblems again. On the other hand, for calculating the nth Fibonacci number, Dynamic Programming should be preferred (See this for details).","Advantages of Divide and Conquer Algorithm:","Disadvantages of Divide and Conquer Algorithm:","Divide and Conquer is a popular algorithmic technique in computer science that involves breaking down a problem into smaller sub-problems, solving each sub-problem independently, and then combining the solutions to the sub-problems to solve the original problem. The basic idea behind this technique is to divide a problem into smaller, more manageable sub-problems that can be solved more easily.","? Merge Sort and Quicksort ","? Median Finding ","? Min and Max finding ","? Matrix Multiplication ","? Closest Pair problem","\u201cIntroduction to Algorithms\u201d by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.\u201cAlgorithms\u201d by Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani.\u201cThe Art of Computer Programming, Volume 1: Fundamental Algorithms\u201d by Donald E. Knuth.","References:Algorithms by Sanjoy Dasgupta, Christos Papadimitriou, Umesh Vazirani Introduction to Algorithms by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. http://en.wikipedia.org/wiki/Karatsuba_algorithm"]},{"lastTimeCrawled":"2024-01-13T15:26:55.421758200","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Mathematical Algorithms - GeeksforGeeks","rating":283,"pageId":"41053361-2b79-4148-ab9f-4fbb91b935c5","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/mathematical-algorithms/?ref=outind","content":["Learn Data Structures and Algorithms | DSA Tutorial\n\nLearn more about Mathematical Algorithms in DSA Self Paced Course\nPractice Problems on Mathematical Algorithms","Mathematical algorithm can be defined as an algorithm or procedure which is utilized to solve a mathematical problem, or mathematical problem which can be solved using DSA.","In the field of DSA, mathematical algorithms refer to those algorithms which are generally used to solve problems related to the field of computer science.","It is a very useful topic for solving problems of computer science and also has vast applications in competitive programming. Some of them are mentioned below:","1. Problem-Solving: It is mostly used in solving complex mathematical ideas in mathematics and computer science.","2. Competitive Programming: Algorithms like Sieve of Eratosthenes, Euclid algorithm, Binary exponentiation are some of the most common topics used in competitive programming.","3. Recurrence relation: A lot of problems in DSA require the usage of recursion. Using the knowledge of mathematics several recurrence relations can be turned into mathematical formulae which makes solving the problem quite an easy task.","4. Heavy calculation: Problems containing complex mathematical concepts and heavy calculations are easily done in comparatively less time using these algorithms instead of manual calculations.","5. Statistics: Mathematical algorithms are also important for data processing, i.e., for converting raw data into useful information and also for analyzing them.","Topics:"," ","Divisibility & Large Numbers:","GCD and LCM:","Series:","Number Digits:","Algebra:","Number System:","Prime Numbers & Primality Tests:","Prime Factorization & Divisors:","Modular Arithmetic:","Factorial:","Fibonacci Numbers:","Catalan Numbers:","nCr Computations:","Set Theory:","Sieve Algorithms:","Euler Totient Function:","Chinese Remainder Theorem:","Some practice Problems:","Quick Links :","If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.","Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."]},{"lastTimeCrawled":"2024-01-13T15:26:55.941351400","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Geometric Algorithms - GeeksforGeeks","rating":265,"pageId":"4ab7501b-c783-411c-9d6b-1beb89745012","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/geometric-algorithms/?ref=outind","content":["Learn Data Structures and Algorithms | DSA Tutorial\n\nLearn more about Geometric Algorithms in DSA Self Paced Course\nPractice Problems on Geometric Algorithms","In different areas of computer science such as robotics, data analysis, computer graphics, virtual reality and etc we need to deal with the geometric aspect or spatial data. The algorithms devised to deal with these types of data are known as geometric algorithms.","1. Data mining: It is very much useful in data mining. Finding the relations between two points are based on the usage of geometric algorithms.","2. Simulation: For simulations of real-life objects we need to understand their geometry and reflect it properly. This is the aspect where geometric algorithms come in handy.","3. Virtual Reality: The usage of these algorithms can be experienced in virtual reality. How to transfer the points and their relative spacing requires the usage of these algorithms.","Topics:","Pattern Printing:","Lines:","Triangle:","Rectangle | Square | Circle:","Quadrilateral:","3D Objects:","Polygon and Convex Hull:","Standard Problems on Geometric Algorithm:","Quick Links :","If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.","Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."]},{"lastTimeCrawled":"2024-01-13T15:26:57.728050300","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Bitwise Algorithms - Data Structures and Algorithms Tutorial - GeeksforGeeks","rating":316,"pageId":"37ab88bd-d558-44cb-a9a5-026329b9676d","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-bitwise-algorithms-data-structures-and-algorithms-tutorial/?ref=outind","content":["Bit stands for binary digit. A bit is the basic unit of information and can only have one of two possible values that is 0 or 1.","In our world, we usually with numbers using the decimal base. In other words. we use the digit 0 to 9 However, there are other number representations that can be quite useful such as the binary number systems.","Introduction to Bitwise Algorithms \u2013 Data Structures and Algorithms Tutorial","Unlike humans, computers have no concepts of words and numbers. They receive data encoded at the lowest level as a series of zeros and ones (0 and 1). These are called bits, and they are the basis for all the commands they receive. We\u2019ll begin by learning about bits and then explore a few algorithms for manipulating bits. We\u2019ll then explore a few algorithms for manipulating bits. The tutorial is meant to be an introduction to bit algorithms for programmers.","An algorithmic operation known as bit manipulation involves the manipulation of bits at the bit level (bitwise). Bit manipulation is all about these bitwise operations. They improve the efficiency of programs by being primitive, fast actions. ","The computer uses this bit manipulation to perform operations like addition, subtraction, multiplication, and division are all done at the bit level. This operation is performed in the arithmetic logic unit (ALU) which is a part of a computer\u2019s CPU. Inside the ALU, all such mathematical operations are performed.","There are different bitwise operations used in bit manipulation. These bit operations operate on the individual bits of the bit patterns. Bit operations are fast and can be used in optimizing time complexity. Some common bit operators are:","Bitwise Operator Truth Table","The bitwise AND operator is denoted using a single ampersand symbol, i.e. &. The & operator takes two equal-length bit patterns as parameters. The two-bit integers are compared. If the bits in the compared positions of the bit patterns are 1, then the resulting bit is 1. If not, it is 0.","Truth table of AND operator","Example: ","Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y","Bitwise ANDof (7 & 4)","Time Complexity: O(1) Auxiliary Space: O(1)","The | Operator takes two equivalent length bit designs as boundaries; if the two bits in the looked-at position are 0, the next bit is zero. If not, it is 1.","Example: ","Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise OR of both X, y","Bitwise OR of (7 | 4)","Explanation: On the basis of truth table of bitwise OR operator we can conclude that the result of ","1 | 1  = 11 | 0 = 10 | 1 = 10 | 0 = 0","We used the similar concept of bitwise operator that are show in the image.","Time Complexity: O(1) Auxiliary Space: O(1)","The ^ operator (also known as the XOR operator) stands for Exclusive Or. Here, if bits in the compared position do not match their resulting bit is 1. i.e, The result of the bitwise XOR operator is 1 if the corresponding bits of two operands are opposite, otherwise 0.","Example: ","Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y","Bitwise OR of (7 ^ 4)","Explanation: On the basis of truth table of bitwise XOR operator we can conclude that the result of ","1 ^ 1  = 01 ^ 0 = 10 ^ 1 = 10 ^ 0 = 0","We used the similar concept of bitwise operator that are show in the image.","Time Complexity: O(1) Auxiliary Space: O(1)","All the above three bitwise operators are binary operators (i.e, requiring two operands in order to operate). Unlike other bitwise operators, this one requires only one operand to operate.","The bitwise Not Operator takes a single value and returns its one\u2019s complement. The one\u2019s complement of a binary number is obtained by toggling all bits in it, i.e, transforming the 0 bit to 1 and the 1 bit to 0.","Truth Table of Bitwise Operator NOT","Example: ","Take two bit values X and Y, where X = 5= (101)2 . Take Bitwise NOT of X.","Explanation: On the basis of truth table of bitwise NOT operator we can conclude that the result of ","~1  = 0~0 = 1","We used the similar concept of bitwise operator that are show in the image.","Implementation of NOT operator:","Time Complexity: O(1) Auxiliary Space: O(1)","The left shift operator is denoted by the double left arrow key (<<). The general syntax for left shift is shift-expression << k. The left-shift operator causes the bits in shift expression to be shifted to the left by the number of positions specified by k. The bit positions that the shift operation has vacated are zero-filled. ","Note: Every time we shift a number towards the left by 1 bit it multiply that number by 2.","Logical left Shift","Example:","Input: Left shift of 5 by 1.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 1) ","Left shift of 5 by 1","Output: 10Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010102, Which is equivalent to 10","Input: Left shift of 5 by 2.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 2)","Left shift of 5 by 2","Output: 20Explanation: All bit of 5 will be shifted by 1 to left side and this result in 101002, Which is equivalent to 20","Input: Left shift of 5 by 3.Binary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 3)","Left shift of 5 by 3","Output: 40Explanation: All bit of 5 will be shifted by 1 to left side and this result in 010002, Which is equivalent to 40","Implementation of Left shift operator:","Time Complexity: O(1) Auxiliary Space: O(1)","The right shift operator is denoted by the double right arrow key (>>). The general syntax for the right shift is \u201cshift-expression >> k\u201d. The right-shift operator causes the bits in shift expression to be shifted to the right by the number of positions specified by k. For unsigned numbers, the bit positions that the shift operation has vacated are zero-filled. For signed numbers, the sign bit is used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used.","Note: Every time we shift a number towards the right by 1 bit it divides that number by 2.","Logical Right Shift","Example:","Input: Right shift of 5 by 1.Binary representation of 5 = 00101 and Right shift of 00101 by 1 (i.e, 00101 >> 1)","Right shift of 5 by 1","Output: 2Explanation: All bit of 5 will be shifted by 1 to Rightside and this result in 00010 Which is equivalent to 2","Input: Right shift of 5 by 2.Binary representation of 5 = 00101 and Right shift of 00101 by 2 (i.e, 00101 >> 2)","Right shift of 5 by 2","Output: 1Explanation: All bit of 5 will be shifted by 2 to Right side and this result in 00001, Which is equivalent to 1","Input: Right shift of 5 by 3.Binary representation of 5 = 00101 and Right shift of 00101 by 3 (i.e, 00101 >> 3)","Right shift of 5 by 3","Output: 0Explanation: All bit of 5 will be shifted by 3 to Right side and this result in 00000, Which is equivalent to 0","Implementation of Right shift operator:","Time Complexity: O(1) Auxiliary Space: O(1)","If we want to set a bit at nth position in the number \u2018num\u2019, it can be done using the \u2018OR\u2019 operator( | ).  ","Note: If the bit would be already set then it would remain unchanged.","Below is the implementation:","Time Complexity: O(1) Auxiliary Space: O(1)","Suppose we want to unset a bit at nth position in number \u2018num\u2019 then we have to do this with the help of \u201cAND\u201d (&) operator.","Below is the implementation:","Time Complexity: O(1) Auxiliary Space: O(1)","Toggling means to turn bit \u2018on'(1) if it was \u2018off'(0) and to turn \u2018off'(0) if it was \u2018on'(1) previously. We will be using the \u2018XOR\u2019 operator here which is this \u2018^\u2019. The reason behind the \u2018XOR\u2019 operator is because of its properties. ","Below is the implementation:","Time Complexity: O(1) Auxiliary Space: O(1)","We used the left shift (<<) operation on 1 to shift the bits to nth position and then use the & operation with number given number, and check if it is not-equals to 0.","Below is the implementation:","Time Complexity: O(1) Auxiliary Space: O(1)","Below is the implementation:","Time Complexity: O(1) Auxiliary Space: O(1)","Below is the implementation:","Time Complexity: O(1) Auxiliary Space: O(1)","The  problem can be solved based on the following observations:","Say x = n % 4. The XOR value depends on the value if x. ","If, x = 0, then the answer is n.   x = 1, then answer is 1.   x = 2, then answer is n+1.   x = 3, then answer is 0.","Below is the implementation of the above approach.","Time Complexity: O(1) Auxiliary Space: O(1)","This can be solved based on the following fact:","If a number N is a power of 2, then the bitwise AND of N and N-1 will be 0. But this will not work if N is 0. So just check these two conditions, if any of these two conditions is true.","Below is the implementation of the above approach.","Time Complexity: O(1) Auxiliary Space: O(1)","Counting set bits means, counting total number of 1\u2019s in the binary representation of an integer. For this problem we go through all the bits of given number and check whether it is set or not by performing AND operation (with 1).","Below is the implementation:","Time Complexity: O(log(n)) Auxiliary Space: O(1)","The idea is to unset the rightmost bit of number n and XOR the result with n. Then the rightmost set bit in n will be the position of the only set bit in the result. Note that if n is odd, we can directly return 1 as the first bit is always set for odd numbers.","Example: The number 20 in binary is 00010100, and the position of the rightmost set bit is 3.","00010100    &               (n = 20)00010011                     (n-1 = 19)\u2014\u2014\u2014\u2014\u2014\u2014-00010000    ^                (XOR result number with n)00010100\u2014\u2014\u2014\u2014\u2014\u2014-00000100 \u2014\u2014->  rightmost set bit will tell us the position","Below is the implementation:","Time Complexity: O(log(n)) Auxiliary Space: O(1)","Related article:"]},{"lastTimeCrawled":"2024-01-13T15:26:58.204602500","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Randomized Algorithms - GeeksforGeeks","rating":283,"pageId":"15c1fc9a-346b-4add-9514-3b194f5590fb","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/randomized-algorithms/?ref=outind","content":["Learn Data Structures and Algorithms | DSA Tutorial\nLearn more about Randomized algorithms in DSA Self Paced Course","An algorithm that uses random numbers to decide what to do next anywhere in its logic is called Randomized Algorithm.","For example, in Randomized Quick Sort, we use a random number to pick the next pivot (or we randomly shuffle the array). Typically, this randomness is used to reduce time complexity or space complexity in other standard algorithms.","Topics :","Introduction:","Problems on Randomized Algorithms:","Recomended:","Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."]},{"lastTimeCrawled":"2024-01-13T15:27:00.506085200","images":[],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"Introduction to Branch and Bound - Data Structures and Algorithms Tutorial - GeeksforGeeks","rating":283,"pageId":"800fc545-d515-4ba8-b443-48cc93934d53","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-branch-and-bound-data-structures-and-algorithms-tutorial/?ref=outind","content":["Branch and bound algorithms are used to find the optimal solution for combinatory, discrete, and general mathematical optimization problems.","A branch and bound algorithm provide an optimal solution to an NP-Hard problem by exploring the entire search space. Through the exploration of the entire search space, a branch and bound algorithm identify possible candidates for solutions step-by-step.","There are many optimization problems in computer science, many of which have a finite number of the feasible shortest path in a graph or minimum spanning tree that can be solved in polynomial time. Typically, these problems require a worst-case scenario of all possible permutations. The branch and bound algorithm create branches and bounds for the best solution.","In this tutorial, we\u2019ll discuss the branch and bound method in detail.","The Branch  algorithms incorporate different search techniques to traverse a state space tree. Different search techniques used in B&B are listed below:","1. LC search (Least Cost Search):","It uses a heuristic cost function to compute the bound values at each node. Nodes are added to the list of live nodes as soon as they get generated.The node with the least value of a cost function selected as a next E-node.","2.BFS(Breadth First Search):It is also known as a FIFO search.It maintains the list of live nodes in first-in-first-out order i.e, in a queue, The live nodes are searched in the FIFO order to make them next E-nodes.","3. DFS (Depth First Search):It is also known as a LIFO search.It maintains the list of live nodes in last-in-first-out order i.e. in a stack.","The live nodes are searched in the LIFO order to make them next E-nodes.","Introduction to Branch and Bound","Branch and bound is an effective solution to some problems, which we have already discussed. We\u2019ll discuss all such cases where branching and binding are appropriate in this section.","▸ Generation of a state space tree:","As in the case of backtracking, B&B generates a state space tree to efficiently search the solution space of a given problem instance.","In B&B, all children of an E-node in a state space tree are produced before any live node gets converted in an E-node. Thus, the E-node remains an E-node until i becomes a dead node.","Unlike backtracking, B&B needs additional factors evaluate a candidate solution:","It optimizes the search for a solution vector in the solution space of a given problem instance.","It is a heuristic function that evaluates the lower and upper bounds on the possible solutions at each node. The bound values are used to search the partial solutions leading to an optimal solution. If a node does not produce a solution better than the best solution obtained thus far, then it is abandoned without further exploration.","The algorithm then branches to another path to get a better solution. The desired solution to the problem is the value of the best solution produced so far.","▸ The reasons to dismiss a search path at the current node :","(i) The bound value of the node is lower than the upper bound in the case of the maximization problem and higher than the lower bound in the case of the minimization problem. (i.e. the bound value of the ade is not better than the value of the best solution obtained until that node).","(ii) The node represents infeasible solutions, de violation of the constraints of the problem.","(iii) The node represents a subset of a feasible solution containing a single point. In this case, if the latest solution is better than the best solution obtained so far the best solution is modified to the value of a feasible solution at that node.","The solution of the Branch and the bound problem can be represented in two ways:","The Branch and Bound method can be classified into three types based on the order in which the state space tree is searched. ","We will now discuss each of these methods in more detail. To denote the solutions in these methods, we will use the variable solution method.","First-In-First-Out is an approach to the branch and bound problem that uses the queue approach to create a state-space tree. In this case, the breadth-first search is performed, that is, the elements at a certain level are all searched, and then the elements at the next level are searched, starting with the first child of the first node at the previous level.","For a given set {A, B, C, D}, the state space tree will be constructed as follows :","State Space tree for set {A, B, C, D}","The above diagram shows that we first consider element A, then element B, then element C and finally we\u2019ll consider the last element which is D. We are performing BFS while exploring the nodes.","So, once the first level is completed. We\u2019ll consider the first element, then we can consider either B, C, or D. If we follow the route then it says that we are doing elements A and D so we will not consider elements B and C. If we select the elements A and D only, then it says that we are selecting elements A and D and we are not considering elements B and C.","Selecting element A","Now, we will expand node 3, as we have considered element B and not considered element A, so, we have two options to explore that is elements C and D. Let\u2019s create nodes 9 and 10 for elements C and D respectively.","Considered element B and not considered element A","Now, we will expand node 4 as we have only considered elements C and not considered elements A and B, so, we have only one option to explore which is element  D. Let\u2019s create node 11 for D."," Considered elements C and not considered elements A and B","Till node 5, we have only considered elements D, and not selected elements A, B, and C. So, We have no more elements to explore, Therefore on node 5, there won\u2019t be any expansion.","Now, we will expand node 6 as we have considered elements A and B, so, we have only two option to explore that is element C and D. Let\u2019s create node 12 and 13 for C and D respectively.","Expand node 6","Now, we will expand node 7 as we have considered elements A and C and not consider element B, so, we have only one option to explore which is element  D. Let\u2019s create node 14 for D.","Expand node 7","Till node 8, we have considered elements A and D, and not selected elements B and C, So, We have no more elements to explore, Therefore on node 8, there won\u2019t be any expansion.","Now, we will expand node 9 as we have considered elements B and C and not considered element A, so, we have only one option to explore which is element  D. Let\u2019s create node 15 for D.","Expand node 9","The Last-In-First-Out approach for this problem uses stack in creating the state space tree. When nodes are added to a state space tree, they are added to a stack. After all nodes of a level have been added, we pop the topmost element from the stack and explore it.","For a given set {A, B, C, D}, the state space tree will be constructed as follows :","State space tree for element {A, B, C, D}","Now the expansion would be based on the node that appears on the top of the stack. Since node 5 appears on the top of the stack, so we will expand node 5. We will pop out node 5 from the stack. Since node 5 is in the last element, i.e., D so there is no further scope for expansion.","The next node that appears on the top of the stack is node 4. Pop-out node 4 and expand. On expansion, element D will be considered and node 6 will be added to the stack shown below:","Expand node 4","The next node is 6 which is to be expanded. Pop-out node 6 and expand. Since node 6 is in the last element, i.e., D so there is no further scope for expansion.","The next node to be expanded is node 3. Since node 3 works on element B so node 3 will be expanded to two nodes, i.e., 7 and 8 working on elements C and D respectively. Nodes 7 and 8 will be pushed into the stack.","The next node that appears on the top of the stack is node 8. Pop-out node 8 and expand. Since node 8 works on element D so there is no further scope for the expansion.","Expand node 3","The next node that appears on the top of the stack is node 7. Pop-out node 7 and expand. Since node 7 works on element C so node 7 will be further expanded to node 9 which works on element D and node 9 will be pushed into the stack.","The next node is 6 which is to be expanded. Pop-out node 6 and expand. Since node 6 is in the last element, i.e., D so there is no further scope for expansion.","Expand node 7","The next node that appears on the top of the stack is node 9. Since node 9 works on element D, there is no further scope for expansion.","The next node that appears on the top of the stack is node 2. Since node 2 works on the element A so it means that node 2 can be further expanded. It can be expanded up to three nodes named 10, 11, 12 working on elements B, C, and D respectively. There new nodes will be pushed into the stack shown as below:","Expand node 2","In the above method, we explored all the nodes using the stack that follows the LIFO principle.","To explore the state space tree, this method uses the cost function. The previous two methods also calculate the cost function at each node but the cost is not been used for further exploration.","In this technique, nodes are explored based on their costs, the cost of the node can be defined using the problem and with the help of the given problem, we can define the cost function. Once the cost function is defined, we can define the cost of the node.Now, Consider a node whose cost has been determined. If this value is greater than U0, this node or its children will not be able to give a solution. As a result, we can kill this node and not explore its further branches. As a result, this method prevents us from exploring cases that are not worth it, which makes it more efficient for us. ","Let\u2019s first consider node 1 having cost infinity shown below:","In the following diagram, node 1 is expanded into four nodes named 2, 3, 4, and 5.","Node 1 is expanded into four nodes named 2, 3, 4, and 5","Assume that cost of the nodes 2, 3, 4, and 5 are 12, 16, 10, and 315 respectively.In this method, we will explore the node which is having the least cost. In the above figure, we can observe that the node with a minimum cost is node 4. So, we will explore node 4 having a cost of 10.","During exploring node 4 which is element C, we can notice that there is only one possible element that remains unexplored which is D (i.e, we already decided not to select elements A, and B). So, it will get expanded to one single element D, let\u2019s say this node number is 6.","Exploring node 4 which is element C","Now, Node 6 has no element left to explore. So, there is no further scope for expansion. Hence the element {C, D} is the optimal way to choose for the least cost.","The Branch and Bound method can be used for solving most combinatorial problems. Some of these problems are given below:","Question","The branch and bound algorithms are one of the most popular algorithms used in optimization problems that we have discussed in our tutorial. We have also explained when a branch and bound algorithm is appropriate for a user to use. In addition, we presented an algorithm based on branches and bounds for assigning jobs. Lastly, we discussed some advantages and disadvantages of branch and bound algorithms.","H"]},{"lastTimeCrawled":"2024-01-13T15:27:02.499188300","images":[{"src":"https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-eb034c715561f90f4edf3091e06bb21e_l3.png","alt":"T(P)                        "}],"favicon":"https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png","pageTitle":"What is Algorithm | Introduction to Algorithms - GeeksforGeeks","rating":286,"pageId":"926fd53c-8224-4ed3-86ab-912e6b2e057c","pageName":"geeksforgeeks.org","url":"https://www.geeksforgeeks.org/introduction-to-algorithms/?ref=outind","content":["The word Algorithm means \u201d A set of finite rules or instructions to be followed in calculations or other problem-solving operations \u201d Or \u201d A procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations\u201d.","Therefore Algorithm refers to a sequence of finite steps to solve a particular problem.","Algorithms play a crucial role in various fields and have many applications. Some of the key areas where algorithms are used include:","These are just a few examples of the many applications of algorithms. The use of algorithms is continually expanding as new technologies and fields emerge, making it a vital component of modern society.","Algorithms can be simple and complex depending on what you want to achieve.","It can be understood by taking the example of cooking a new recipe. To cook a new recipe, one reads the instructions and steps and executes them one by one, in the given sequence. The result thus obtained is the new dish is cooked perfectly. Every time you use your phone, computer, laptop, or calculator you are using Algorithms. Similarly, algorithms help to do a task in programming to get the expected output.","The Algorithm designed are language-independent, i.e. they are just plain instructions that can be implemented in any language, and yet the output will be the same, as expected.","As one would not follow any written instructions to cook the recipe, but only the standard one. Similarly, not all written instructions for programming are an algorithm. For some instructions to be an algorithm, it must have the following characteristics:","There are several types of algorithms available. Some important algorithms are:","It is the simplest approach to a problem. A brute force algorithm is the first approach that comes to finding when we see a problem.","A recursive algorithm is based on recursion. In this case, a problem is broken into several sub-parts and called the same function again and again.","The backtracking algorithm builds the solution by searching among all possible solutions. Using this algorithm, we keep on building the solution following criteria. Whenever a solution fails we trace back to the failure point build on the next solution and continue this process till we find the solution or all possible solutions are looked after.","Searching algorithms are the ones that are used for searching elements or groups of elements from a particular data structure. They can be of different types based on their approach or the data structure in which the element should be found.","Sorting is arranging a group of data in a particular manner according to the requirement. The algorithms which help in performing this function are called sorting algorithms. Generally sorting algorithms are used to sort groups of data in an increasing or decreasing manner.","Hashing algorithms work similarly to the searching algorithm. But they contain an index with a key ID. In hashing, a key is assigned to specific data.","This algorithm breaks a problem into sub-problems, solves a single sub-problem, and merges the solutions to get the final solution. It consists of the following three steps:","In this type of algorithm, the solution is built part by part. The solution for the next part is built based on the immediate benefit of the next part. The one solution that gives the most benefit will be chosen as the solution for the next part.","This algorithm uses the concept of using the already found solution to avoid repetitive calculation of the same part of the problem. It divides the problem into smaller overlapping subproblems and solves them.","In the randomized algorithm, we use a random number so it gives immediate benefit. The random number helps in deciding the expected outcome.","To learn more about the types of algorithms refer to the article about \u201cTypes of Algorithms\u201c.","To write an algorithm, the following things are needed as a pre-requisite: ","Then the algorithm is written with the help of the above parameters such that it solves the problem.","Example: Consider the example to add three numbers and print the sum.","As discussed above, to write an algorithm, its prerequisites must be fulfilled. ","Now let\u2019s design the algorithm with the help of the above pre-requisites:","Algorithm to add 3 numbers and print their sum: ","To test the algorithm, let\u2019s implement it in C language.","Program:","Here is the step-by-step algorithm of the code:","Time complexity: O(1)Auxiliary Space: O(1) ","One problem, many solutions: The solution to an algorithm can be or cannot be more than one. It means that while implementing the algorithm, there can be more than one method to implement it. For example, in the above problem of adding 3 numbers, the sum can be calculated in many ways:","For a standard algorithm to be good, it must be efficient. Hence the efficiency of an algorithm must be checked and maintained. It can be in two stages:","\u201cPriori\u201d means \u201cbefore\u201d. Hence Priori analysis means checking the algorithm before its implementation. In this, the algorithm is checked when it is written in the form of theoretical steps. This Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation. This is done usually by the algorithm designer. This analysis is independent of the type of hardware and language of the compiler. It gives the approximate answers for the complexity of the program.","\u201cPosterior\u201d means \u201cafter\u201d. Hence Posterior analysis means checking the algorithm after its implementation. In this, the algorithm is checked by implementing it in any programming language and executing it. This analysis helps to get the actual and real analysis report about correctness(for every possible input/s if it shows/returns correct output or not), space required, time consumed, etc. That is, it is dependent on the language of the compiler and the type of hardware used.","An algorithm is defined as complex based on the amount of Space and Time it consumes. Hence the Complexity of an algorithm refers to the measure of the time that it will need to execute and get the expected output, and the Space it will need to store all the data (input, temporary data, and output). Hence these two factors define the efficiency of an algorithm. The two factors of Algorithm Complexity are:","Therefore the complexity of an algorithm can be divided into two types:","1. Space Complexity: The space complexity of an algorithm refers to the amount of memory required by the algorithm to store the variables and get the result. This can be for inputs, temporary operations, or outputs. ","How to calculate Space Complexity?The space complexity of an algorithm is calculated by determining the following 2 components:  ","Example: Consider the below algorithm for Linear Search","Step 1: STARTStep 2: Get n elements of the array in arr and the number to be searched in xStep 3: Start from the leftmost element of arr[] and one by one compare x with each element of arr[]Step 4: If x matches with an element, Print True.Step 5: If x doesn\u2019t match with any of the elements, Print False.Step 6: ENDHere, There are 2 variables arr[], and x, where the arr[] is the variable part of n elements and x is the fixed part. Hence S(P) = 1+n. So, the space complexity depends on n(number of elements). Now, space depends on data types of given variables and constant types and it will be multiplied accordingly.","2. Time Complexity: The time complexity of an algorithm refers to the amount of time required by the algorithm to execute and get the result. This can be for normal operations, conditional if-else statements, loop statements, etc.","How to Calculate, Time Complexity?The time complexity of an algorithm is also calculated by determining the following 2 components: ","Example: In the algorithm of Linear Search above, the time complexity is calculated as follows:","Step 1: \u2013Constant TimeStep 2: \u2014 Variable Time (Taking n inputs)Step 3: \u2013Variable Time (Till the length of the Array (n) or the index of the found element)Step 4: \u2013Constant TimeStep 5: \u2013Constant TimeStep 6: \u2013Constant TimeHence, T(P) = 1 + n + n(1 + 1) + 1 = 2 + 3n, which can be said as T(n).","R"]}]