[
    {
        "lastTimeCrawled": "2024-01-03T08:57:26.054600",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Red-Black Tree - GeeksforGeeks",
        "rating": 959,
        "pageId": "9d441651-b0a1-43af-8e22-9363b7a1ec55",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-red-black-tree/?ref=outind",
        "content": [
            "When it comes to searching and sorting data, one of the most fundamental data structures is the binary search tree. However, the performance of a binary search tree is highly dependent on its shape, and in the worst case, it can degenerate into a linear structure with a time complexity of O(n). This is where Red Black Trees come in, they are a type of balanced binary search tree that use a specific set of rules to ensure that the tree is always balanced. This balance guarantees that the time complexity for operations such as insertion, deletion, and searching is always O(log n), regardless of the initial shape of the tree.",
            "Red Black Trees are self-balancing, meaning that the tree adjusts itself automatically after each insertion or deletion operation. It uses a simple but powerful mechanism to maintain balance, by coloring each node in the tree either red or black. ",
            "Red Black Tree-",
            "Red-Black tree is a binary search tree in which every node is colored with either red or black. It is a type of self balancing binary search tree. It has a good efficient worst case running time complexity.",
            "The Red-Black tree satisfies all the properties of binary search tree in addition to that it satisfies following additional properties \u2013",
            "1. Root property: The root is black.",
            "2. External property: Every leaf (Leaf is a NULL child of a node) is black in Red-Black tree.",
            "3. Internal property: The children of a red node are black. Hence possible parent of red node is a black node.",
            "4. Depth property: All the leaves have the same black depth.",
            "5. Path property: Every simple path from root to descendant leaf node contains same number of black nodes. ",
            "The result of all these above-mentioned properties is that the Red-Black tree is roughly balanced.",
            "Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that the height of the tree remains O(log n) after every insertion and deletion, then we can guarantee an upper bound of O(log n) for all these operations. The height of a Red-Black tree is always O(log n) where n is the number of nodes in the tree. ",
            "\u201cn\u201d is the total number of elements in the red-black tree. ",
            "Comparison with AVL Tree:The AVL trees are more balanced compared to Red-Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves frequent insertions and deletions, then Red-Black trees should be preferred. And if the insertions and deletions are less frequent and search is a more frequent operation, then AVL tree should be preferred over the Red-Black Tree.",
            "How does a Red-Black Tree ensure balance?A simple example to understand balancing is, that a chain of 3 nodes is not possible in the Red-Black tree. We can try any combination of colors and see if all of them violate the Red-Black tree property. ",
            "Proper structure of three noded Red-black tree",
            "Black height is the number of black nodes on a path from the root to a leaf. Leaf nodes are also counted black nodes. From the above properties 3 and 4, we can derive, a Red-Black Tree of height h has black-height >= h/2. ",
            "Number of nodes from a node to its farthest descendant leaf is no more than twice as the number of nodes to the nearest descendant leaf.",
            "Every Red Black Tree with n nodes has height <= 2Log2(n+1) This can be proved using the following facts:",
            "From the above points, we can conclude the fact that Red Black Tree with n nodes has a height <= 2Log2(n+1)",
            "As every red-black tree is a special case of a binary tree so the searching algorithm of a red-black tree is similar to that of a binary tree.",
            "Algorithm:",
            "For the program, you can refer it for AVL tree. ",
            "Example: Searching 11 in the following red-black tree.  ",
            "Solution: ",
            " Just follow the blue bubble.",
            "In this post, we introduced Red-Black trees and discussed how balance is ensured. The hard part is to maintain balance when keys are added and removed. We have also seen how to search an element from the red-black tree. We will soon be discussing insertion and deletion operations in coming posts on the Red-Black tree.",
            "1) Is it possible to have all black nodes in a Red-Black tree? 2) Draw a Red-Black Tree that is not an AVL tree structure-wise?",
            "Red-Black Tree Insertion Red-Black Tree Deletion "
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:38.116404600",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Searching Algorithms - GeeksforGeeks",
        "rating": 959,
        "pageId": "cfa98325-c3e8-403e-bff3-7893e7d9634f",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/searching-algorithms/?ref=outind",
        "content": [
            "Learn Data Structures and Algorithms | DSA Tutorial\n\nLearn more about Searching Algorithms in DSA Self Paced Course\nPractice Problems on Searching Algorithms\nTop Quizzes on Searching Algorithms",
            "Searching Algorithms are designed to check for an element or retrieve an element from any data structure where it is stored.",
            "Searching Algorithms",
            "Based on the type of search operation, these algorithms are generally classified into two categories:",
            "Linear Search to find the element \u201c20\u201d in a given list of numbers",
            "Linear-Search",
            "Binary Search to find the element \u201c23\u201d in a given list of numbers",
            "Binary Search",
            "Topic :",
            "Searching Algorithm:",
            "Comparisons:",
            "Library Implementations of Searching Algorithms :",
            "Some standard problems on Searching:",
            "Quick Links:",
            "Recomended:",
            "If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:25.350570200",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction of B+ Tree - GeeksforGeeks",
        "rating": 957,
        "pageId": "dc496adf-78c7-4fce-b681-1c1285e7497a",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-of-b-tree/?ref=outind",
        "content": [
            "B + Tree is a variation of the B-tree data structure. In a B + tree, data pointers are stored only at the leaf nodes of the tree. In a B+ tree structure of a leaf node differs from the structure of internal nodes. The leaf nodes have an entry for every value of the search field, along with a data pointer to the record (or to the block that contains this record). The leaf nodes of the B+ tree are linked together to provide ordered access to the search field to the records. Internal nodes of a B+ tree are used to guide the search. Some search field values from the leaf nodes are repeated in the internal nodes of the B+ tree.",
            "Some differences between B+ Tree and B Tree are stated below.",
            "Parameters",
            "B+ Tree",
            " B Tree",
            "Structure",
            "Separate leaf nodes for data storage and internal nodes for indexing",
            "Nodes store both keys and data values",
            "Leaf Nodes",
            "Leaf nodes form a linked list for efficient range-based queries",
            "Leaf nodes do not form a linked list",
            "Order",
            "Higher order (more keys)",
            " Lower order (fewer keys)",
            "Key Duplication",
            "Typically allows key duplication in leaf nodes",
            "Usually does not allow key duplication",
            "Disk Access",
            "Better disk access due to sequential reads in a linked list structure",
            "More disk I/O due to non-sequential reads in internal nodes",
            "Applications",
            "Database systems, file systems, where range queries are common",
            "In-memory data structures, databases, general-purpose use",
            "Performance",
            "Better performance for range queries and bulk data retrieval",
            "Balanced performance for search, insert, and delete operations",
            "Memory Usage",
            "Requires more memory for internal nodes",
            "Requires less memory as keys and values are stored in the same node",
            "In order, to implement dynamic multilevel indexing, B-tree and B+ tree are generally employed. The drawback of the B-tree used for indexing, however, is that it stores the data pointer (a pointer to the disk file block containing the key value), corresponding to a particular key value, along with that key value in the node of a B-tree. This technique greatly reduces the number of entries that can be packed into a node of a B-tree, thereby contributing to the increase in the number of levels in the B-tree, hence increasing the search time of a record. B+ tree eliminates the above drawback by storing data pointers only at the leaf nodes of the tree. Thus, the structure of the leaf nodes of a B+ tree is quite different from the structure of the internal nodes of the B tree. It may be noted here that, since data pointers are present only at the leaf nodes, the leaf nodes must necessarily store all the key values along with their corresponding data pointers to the disk file block, in order to access them. ",
            "Moreover, the leaf nodes are linked to providing ordered access to the records. The leaf nodes, therefore form the first level of the index, with the internal nodes forming the other levels of a multilevel index. Some of the key values of the leaf nodes also appear in the internal nodes, to simply act as a medium to control the searching of a record. From the above discussion, it is apparent that a B+ tree, unlike a B-tree, has two orders, \u2018a\u2019 and \u2018b\u2019, one for the internal nodes and the other for the external (or leaf) nodes. ",
            "B+ Trees",
            "B+ Trees contain two types of nodes:",
            "Structure of  Internal Node",
            "Structure of Lead Node",
            "Diagram-II Using the Pnext pointer it is viable to traverse all the leaf nodes, just like a linked list, thereby achieving ordered access to the records stored in the disk. ",
            "Tree Pointer",
            "Searching Record in B+ Trees",
            "Let us suppose we have to find 58 in the B+ Tree. We will start by fetching from the root node then we will move to the leaf node, which might contain a record of 58. In the image given above, we will get 58 between 50 and 70. Therefore, we will we are getting a leaf node in the third leaf node and get 58 there. If we are unable to find that node, we will return that \u2018record not founded\u2019 message.",
            "Insertion in B+ Trees is done via the following steps.",
            "For more, refer to Insertion in a B+ Trees.",
            "Deletion in B+ Trees is just not deletion but it is a combined process of Searching, Deletion, and Balancing. In the last step of the Deletion Process, it is mandatory to balance the B+ Trees, otherwise, it fails in the property of B+ Trees.",
            "For more, refer to Deletion in B+ Trees.",
            "In conclusion, B+ trees are an essential component of contemporary database systems since they significantly improve database performance and make efficient data management possible.",
            "Answer:",
            "B+ Tree is balanced binary search tree that can simply be a B Tree, where data is stored in keys, not key-value pairs.",
            "Answer:",
            "The height of the B+ Trees is mostly balanced and is comparatively lesser than B-Trees.",
            "Answer:",
            "B+ Trees are often used for disk-based storage systems.",
            "S"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:33.231758300",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Data Structures - GeeksforGeeks",
        "rating": 956,
        "pageId": "66501139-aac5-42e5-8505-c89863805bc7",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-data-structures/?ref=outind",
        "content": [
            "A data structure is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexities of different tasks. ",
            "The choice of a good data structure makes it possible to perform a variety of critical operations effectively. An efficient data structure also uses minimum memory space and execution time to process the structure. A data structure is not only used for organising the data. It is also used for processing, retrieving, and storing data. There are different basic and advanced types of data structures that are used in almost every program or software system that has been developed. So we must have good knowledge of data structures.",
            "The structure of the data and the synthesis of the algorithm are relative to each other. Data presentation must be easy to understand so the developer, as well as the user, can make an efficient implementation of the operation.Data structures provide an easy way of organising, retrieving, managing, and storing data.",
            "Here is a list of the needs for data.",
            "An array is a collection of data items stored at contiguous memory locations. The idea is to store multiple items of the same type together. This makes it easier to calculate the position of each element by simply adding an offset to a base value, i.e., the memory location of the first element of the array (generally denoted by the name of the array). ",
            "Array Data Structure",
            "Like arrays, Linked List is a linear data structure. Unlike arrays, linked list elements are not stored at a contiguous location; the elements are linked using pointers. ",
            "Linked Data Structure",
            "Stack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out). In stack, all insertion and deletion are permitted at only one end of the list.",
            "Stack Operations:",
            "Like Stack, Queue is a linear structure which follows a particular order in which the operations are performed. The order is First In First Out (FIFO). In the queue, items are inserted at one end and deleted from the other end. A good example of the queue is any queue of consumers for a resource where the consumer that came first is served first. The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added. ",
            "Queue Data Structure",
            "Queue Operations:",
            "Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures. A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. It is implemented mainly using Links. ",
            "A Binary Tree is represented by a pointer to the topmost node in the tree. If the tree is empty, then the value of root is NULL. A Binary Tree node contains the following parts. ",
            "Binary Tree Data Structure",
            "A Binary Search Tree is a Binary Tree following the additional properties: ",
            "A Binary tree having the following properties is known as Binary search tree (BST).",
            "Binary Search Tree Data Structure",
            "A Heap is a special Tree-based data structure in which the tree is a complete binary tree. Generally, Heaps can be of two types: ",
            "Max and Min Heap",
            "Hashing is an important Data Structure which is designed to use a special function called the Hash function which is used to map a given value with a particular key for faster access of elements. The efficiency of mapping depends on the efficiency of the hash function used. ",
            "Let a hash function H(x) maps the value x at the index x%10 in an Array. For example, if the list of values is [11, 12, 13, 14, 15] it will be stored at positions {1, 2, 3, 4, 5} in the array or Hash table respectively. ",
            "Hash Data Structure",
            "A matrix represents a collection of numbers arranged in an order of rows and columns. It is necessary to enclose the elements of a matrix in parentheses or brackets. ",
            "A matrix with 9 elements is shown below. ",
            "Matrix",
            "Trie is an efficient information retrieval data structure. Using Trie, search complexities can be brought to an optimal limit (key length). If we store keys in the binary search tree, a well-balanced BST will need time proportional to M * log N, where M is maximum string length and N is the number of keys in the tree. Using Trie, we can search the key in O(M) time. However, the penalty is on Trie storage requirements. ",
            "Trie Data Structure",
            "Data structures are used in various fields such as:",
            "M"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:28.640492",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Hashing - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 954,
        "pageId": "3c44fd95-9ec2-4ea1-a525-fd8c6b91f467",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "Hashing refers to the process of generating a fixed-size output from an input of variable size using the mathematical formulas known as hash functions. This technique determines an index or location for the storage of an item in a data structure.",
            "What is Hashing",
            "Table of Contents/Roadmap",
            "Every day, the data on the internet is increasing multifold and it is always a struggle to store this data efficiently. In day-to-day programming, this amount of data might not be that big, but still, it needs to be stored, accessed, and processed easily and efficiently. A very common data structure that is used for such a purpose is the Array data structure.",
            "Now the question arises if Array was already there, what was the need for a new data structure! The answer to this is in the word \u201cefficiency\u201c. Though storing in Array takes O(1) time, searching in it takes at least O(log n) time. This time appears to be small, but for a large data set, it can cause a lot of problems and this, in turn, makes the Array data structure inefficient. ",
            "So now we are looking for a data structure that can store the data and search in it in constant time, i.e. in O(1) time. This is how Hashing data structure came into play. With the introduction of the Hash data structure, it is now possible to easily store data in constant time and retrieve them in constant time as well.",
            "There are majorly three components of hashing:",
            "Components of Hashing",
            "Suppose we have a set of strings {\u201cab\u201d, \u201ccd\u201d, \u201cefg\u201d} and we would like to store it in a table. ",
            "Our main objective here is to search or update the values stored in the table quickly in O(1) time and we are not concerned about the ordering of strings in the table. So the given set of strings can act as a key and the string itself will act as the value of the string but how to store the value corresponding to the key? ",
            "Mapping key with indices of array",
            "The above technique enables us to calculate the location of a given string by using a simple hash function and rapidly find the value that is stored in that location. Therefore the idea of hashing seems like a great way to store (key, value) pairs of the data in a table.",
            "The hash function creates a mapping between key and value, this is done through the use of mathematical formulas known as hash functions. The result of the hash function is referred to as a hash value or hash. The hash value is a representation of the original string of characters but usually smaller than the original.",
            "For example: Consider an array as a Map where the key is the index and the value is the value at that index. So for an array A if we have index i which will be treated as the key then we can find the value by simply looking at the value at A[i].simply looking up A[i]. ",
            "There are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:",
            "A hash function that maps every item into its own unique slot is known as a perfect hash function. We can construct a perfect hash function if we know the items and the collection will never change but the problem is that there is no systematic way to construct a perfect hash function given an arbitrary collection of items. Fortunately, we will still gain performance efficiency even if the hash function isn\u2019t perfect. We can achieve a perfect hash function by increasing the size of the hash table so that every possible value can be accommodated. As a result, each item will have a unique slot. Although this approach is feasible for a small number of items, it is not practical when the number of possibilities is large.",
            "So, We can construct our hash function to do the same but the things that we must be careful about while constructing our own hash function.",
            "A\u202fgood hash function\u202fshould have the following properties:",
            "If we consider the above example, the hash function we used is the sum of the letters, but if we examined the hash function closely then the problem can be easily visualized that for different strings same hash value is begin generated by the hash function. ",
            "For example: {\u201cab\u201d, \u201cba\u201d} both have the same hash value, and string {\u201ccd\u201d,\u201dbe\u201d} also generate the same hash value, etc. This is known as collision and it creates problem in searching, insertion, deletion, and updating of value. ",
            "The hashing process generates a small number for a big key, so there is a possibility that two keys could produce the same value. The situation where the newly inserted key maps to an already occupied, and it must be handled using some collision handling technology.",
            "What is Collision in Hashing",
            "There are mainly two methods to handle collision: ",
            "Collision resolution technique",
            "The idea is to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.",
            "Example: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.",
            "Let\u2019s see step by step approach to how to solve the above problem:",
            "Hash table",
            "Insert 12",
            "Insert 22",
            "Insert 15",
            "Insert 25",
            "Hence In this way, the separate chaining method is used as the collision resolution technique.",
            "In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.",
            "In linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location. ",
            "Algorithm:",
            "Example: Let us consider a simple hash function as \u201ckey mod 5\u201d and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93. ",
            "Hash table",
            "Insert 50 into hash table",
            "Insert 70 into hash table",
            "Insert 76 into hash table",
            "Insert 85 into hash table",
            "Insert 93 into hash table",
            "Quadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.",
            "An example sequence using quadratic probing is:",
            "H + 12, H + 22, H + 32, H + 42\u2026\u2026\u2026\u2026\u2026\u2026\u2026. H + k2",
            "This method is also known as the mid-square method because in this method we look for i2\u2018th probe (slot) in i\u2019th iteration and the value of i = 0, 1, . . . n \u2013 1. We always start from the original hash location. If only the location is occupied then we check the other slots.",
            "Let hash(x) be the slot index computed using the hash function and n be the size of the hash table.",
            "If the slot hash(x) % n is full, then we try (hash(x) + 12) % n.If (hash(x) + 12) % n is also full, then we try (hash(x) + 22) % n.If (hash(x) + 22) % n is also full, then we try (hash(x) + 32) % n.This process will be repeated for all the values of i until an empty slot is found",
            "Example: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i2 . Insert = 22, 30, and 50",
            "Hash table",
            "Insert key 22 and 30 in the hash table",
            "Insert key 50 in the hash table",
            "Double hashing is a collision resolving technique in Open Addressed Hash tables. Double hashing make use of two hash function, ",
            "This combination of hash functions is of the form ",
            "where ",
            "Complexity of the Double hashing algorithm: ",
            "Example: Insert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is h1\u200b(k) = k mod 7 and second hash-function is h2(k) = 1 + (k mod 5)",
            "Insert key 27 in the hash table",
            "Insert key 43 in the hash table",
            "Insert key 692 in the hash table",
            "Insert key 72 in the hash table",
            "The load factor of the hash table can be defined as the number of items the hash table contains divided by the size of the hash table. Load factor is the decisive parameter that is used when we want to rehash the previous hash function or want to add more elements to the existing hash table.",
            "It helps us in determining the efficiency of the hash function i.e. it tells whether the hash function which we are using is distributing the keys uniformly or not in the hash table.",
            "As the name suggests, rehashing means hashing again. Basically, when the load factor increases to more than its predefined value (the default value of the load factor is 0.75), the complexity increases. So to overcome this, the size of the array is increased (doubled) and all the values are hashed again and stored in the new double-sized array to maintain a low load factor and low complexity.",
            "From the above discussion, we conclude that the goal of hashing is to resolve the challenge of finding an item quickly in a collection. For example, if we have a list of millions of English words and we wish to find a particular term then we would use hashing to locate and find it more efficiently. It would be inefficient to check each item on the millions of lists until we find a match. Hashing reduces search time by restricting the search to a smaller set of words at the beginning."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:24.007902700",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "AVL Tree Data Structure - GeeksforGeeks",
        "rating": 953,
        "pageId": "2980d7e9-a0c0-4c1b-b5d7-6e84dcfcec3c",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-avl-tree/?ref=outind",
        "content": [
            "An AVL tree defined as a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees for any node cannot be more than one.",
            "The difference between the heights of the left subtree and the right subtree for any node is known as the balance factor of the node.",
            "The AVL tree is named after its inventors, Georgy Adelson-Velsky and Evgenii Landis, who published it in their 1962 paper \u201cAn algorithm for the organization of information\u201d.",
            "AVL tree",
            "The above tree is AVL because the differences between the heights of left and right subtrees for every node are less than or equal to 1.",
            "An AVL tree may rotate in one of the following four ways to keep itself balanced:",
            "Left Rotation:",
            "When a node is added into the right subtree of the right subtree, if the tree gets out of balance, we do a single left rotation.",
            "Left-Rotation in AVL tree",
            "Right Rotation:",
            "If a node is added to the left subtree of the left subtree, the AVL tree may get out of balance, we do a single right rotation.",
            "Right-Rotation in AVL Tree",
            "Left-Right Rotation:",
            "A left-right rotation is a combination in which first left rotation takes place after that right rotation executes.",
            "Left-Right Rotation in AVL tree",
            "Right-Left Rotation:",
            "A right-left rotation is a combination in which first right rotation takes place after that left rotation executes.",
            "Right-Left Rotation in AVL tree",
            "Related Articles:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:41.956870300",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks",
        "rating": 953,
        "pageId": "91d78194-277b-442b-81c3-fecf5f654f29",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/heap-sort/?ref=outind",
        "content": [
            "Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.",
            "To solve the problem follow the below idea:",
            "First convert the array into heap data structure using heapify, then one by one delete the root node of the Max-heap and replace it with the last node in the heap and then heapify the root of the heap. Repeat this process until size of heap is greater than 1.",
            "To understand heap sort more clearly, let\u2019s take an unsorted array and try to sort it using heap sort.Consider the array: arr[] = {4, 10, 3, 5, 1}.",
            "Build Complete Binary Tree: Build a complete binary tree from the array.",
            "Heap sort algorithm | Build Complete Binary Tree",
            "Transform into max heap: After that, the task is to construct a tree from that unsorted array and try to convert it into max heap.",
            "Heap sort algorithm | Max Heapify constructed binary tree",
            "Perform heap sort: Remove the maximum element in each step (i.e., move it to the end position and remove that) and then consider the remaining elements and transform it into a max heap.",
            "Heap sort algorithm | Remove maximum from root and max heapify",
            "Heap sort algorithm | Remove next maximum from root nad max heapify",
            "Heap sort algorithm | Repeat previous step",
            "Heap sort algorithm | Final sorted array",
            "Time Complexity: O(N log N)Auxiliary Space: O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation.",
            "Q1. What are the two phases of Heap Sort?",
            "The heap sort algorithm consists of two phases. In the first phase, the array is converted into a max heap. And in the second phase, the highest element is removed (i.e., the one at the tree root) and the remaining elements are used to create a new max heap.",
            "Q2. Why Heap Sort is not stable?",
            "The heap sort algorithm is not a stable algorithm. This algorithm is not stable because the operations that are performed in a heap can change the relative ordering of the equivalent keys.",
            "Q3. Is Heap Sort an example of the \u201cDivide and Conquer\u201d algorithm?",
            "Heap sort is NOT at all a Divide and Conquer algorithm. It uses a heap data structure to efficiently sort its element and not a \u201cdivide and conquer approach\u201d to sort the elements.",
            "Q4. Which sorting algorithm is better \u2013 Heap sort or Merge Sort?",
            "The answer lies in the comparison of their time complexity and space requirements. The Merge sort is slightly faster than the Heap sort. But on the other hand merge sort takes extra memory. Depending on the requirement, one should choose which one to use.",
            "Q5. Why is Heap sort better than Selection sort?",
            "Heap sort is similar to selection sort, but with a better way to get the maximum element. It takes advantage of the heap data structure to get the maximum element in constant time "
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:43.733075500",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Bucket Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks",
        "rating": 953,
        "pageId": "e29bab95-b56a-45cc-9fda-39734b81bc63",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/bucket-sort-2/?ref=outind",
        "content": [
            "Bucket sort is a sorting technique that involves dividing elements into various groups, or buckets. These buckets are formed by uniformly distributing the elements. Once the elements are divided into buckets, they can be sorted using any other sorting algorithm. Finally, the sorted elements are gathered together in an ordered fashion.",
            "Create n empty buckets (Or lists) and do the following for every array element arr[i].",
            "To apply bucket sort on the input array [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68], we follow these steps:",
            "Step 1: Create an array of size 10, where each slot represents a bucket.",
            "Creating Buckets for sorting",
            "Step 2: Insert elements into the buckets from the input array based on their range.",
            "Inserting elements into the buckets:",
            "Inserting Array elements into respective buckets",
            "Step 3: Sort the elements within each bucket. In this example, we use quicksort (or any stable sorting algorithm) to sort the elements within each bucket.",
            "Sorting the elements within each bucket:",
            "Sorting individual bucket",
            "Step 4: Gather the elements from each bucket and put them back into the original array.",
            "Gathering elements from each bucket:",
            "Inserting buckets in ascending order into the resultant array",
            "Step 5: The original array now contains the sorted elements.",
            "The final sorted array using bucket sort for the given input is [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94].",
            "Return the Sorted Array",
            "Below is the implementation for the Bucket Sort:",
            "Time Complexity: O(n2),",
            "Auxiliary Space: O(n+k)"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:32.274089800",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Advanced Data Structures - GeeksforGeeks",
        "rating": 952,
        "pageId": "84c71fa7-db8e-4a67-a680-9f55ce7a4d94",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/advanced-data-structures/?ref=outind",
        "content": [
            "Learn Data Structures and Algorithms | DSA Tutorial\nLearn more about Advanced Data Structures in DSA Self Paced Course\nPractice Problems on all Advanced Data Structure",
            "Data Structures are used to store and manage data in an efficient and organised way for faster and easy access and modification of Data. Some of the basic data structures are Arrays, LinkedList, Stacks, Queues etc.",
            "This page will contain some of the complex and advanced Data Structures like Disjoint Sets, Self-Balancing Trees, Segment Trees, Tries etc.",
            "Topics:",
            "Advanced Lists:",
            "n-ary Tree:",
            "Self Balancing BSTs:",
            "Trie:",
            "Segment Tree:",
            "Binary Indexed Tree:",
            "Suffix Array and Suffix Tree",
            "K-Dimensional Tree:",
            "Disjoint Set:",
            "Some other Data Structure:",
            "Quick Links:",
            "Recomended:",
            "If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.",
            "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:36.034423",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Types of Asymptotic Notations in Complexity Analysis of Algorithms - GeeksforGeeks",
        "rating": 952,
        "pageId": "456fcf84-14d8-4350-821f-66e18652d7ce",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/?ref=outind",
        "content": [
            "We have discussed Asymptotic Analysis, and Worst, Average, and Best Cases of Algorithms. The main idea of asymptotic analysis is to have a measure of the efficiency of algorithms that don\u2019t depend on machine-specific constants and don\u2019t require algorithms to be implemented and time taken by programs to be compared. Asymptotic notations are mathematical tools to represent the time complexity of algorithms for asymptotic analysis.",
            "Asymptotic Notations:",
            ".Asymptotic Notations are mathematical tools that allow you to analyze an algorithm\u2019s running time by identifying its behavior as its input size grows.",
            ".This is also referred to as an algorithm\u2019s growth rate.",
            ".You can\u2019t compare two algorithm\u2019s head to head.",
            ".You compare space and time complexity using asymptotic analysis.",
            ".It compares two algorithms based on changes in their performance as the input size is increased or decreased.",
            "There are mainly three asymptotic notations:",
            "Theta notation encloses the function from above and below. Since it represents the upper and the lower bound of the running time of an algorithm, it is used for analyzing the average-case complexity of an algorithm.",
            ".Theta (Average Case) You add the running times for each possible input combination and take the average in the average case.",
            "Let g and f be the function from the set of natural numbers to itself. The function f is said to be Θ(g), if there are constants c1, c2 > 0 and a natural number n0 such that c1* g(n) ≤ f(n) ≤ c2 * g(n) for all n ≥ n0",
            "Theta notation",
            "Θ (g(n)) = {f(n): there exist positive constants c1, c2 and n0 such that 0 ≤ c1 * g(n) ≤ f(n) ≤ c2 * g(n) for all n ≥ n0}",
            "Note: Θ(g) is a set",
            "The above expression can be described as if f(n) is theta of g(n), then the value f(n) is always between c1 * g(n) and c2 * g(n) for large values of n (n ≥ n0). The definition of theta also requires that f(n) must be non-negative for values of n greater than n0.",
            "The execution time serves as both a lower and upper bound on the algorithm\u2019s time complexity. ",
            "It exist as both, most, and least boundaries for a given input value.",
            "A simple way to get the Theta notation of an expression is to drop low-order terms and ignore leading constants. For example, Consider the expression 3n3 + 6n2 + 6000 = Θ(n3), the dropping lower order terms is always fine because there will always be a number(n) after which Θ(n3) has higher values than Θ(n2) irrespective of the constants involved. For a given function g(n), we denote Θ(g(n)) is following set of functions. ",
            "Examples :",
            "{ 100 , log (2000) , 10^4 } belongs to Θ(1){ (n/4) , (2n+3) , (n/100 + log(n)) } belongs to Θ(n){ (n^2+n) , (2n^2) , (n^2+log(n))} belongs to Θ( n2)",
            "Note: Θ provides exact bounds.",
            "Big-O notation represents the upper bound of the running time of an algorithm. Therefore, it gives the worst-case complexity of an algorithm.",
            ".It is the most widely used notation for Asymptotic analysis..It specifies the upper bound of a function..The maximum time required by an algorithm or the worst-case time complexity..It returns the highest possible output value(big-O) for a given input..Big-Oh(Worst Case) It is defined as the condition that allows an algorithm to complete statement execution in the longest amount of time possible. ",
            "If f(n) describes the running time of an algorithm, f(n) is O(g(n)) if there exist a positive constant C and n0 such that, 0 ≤ f(n) ≤ cg(n) for all n ≥ n0",
            "It returns the highest possible output value (big-O)for a given input.",
            "The execution time serves as an upper bound on the algorithm\u2019s time complexity.",
            "O(g(n)) = { f(n): there exist positive constants c and n0 such that 0 ≤ f(n) ≤ cg(n) for all n ≥ n0 }",
            "For example, Consider the case of Insertion Sort. It takes linear time in the best case and quadratic time in the worst case. We can safely say that the time complexity of the Insertion sort is O(n2). Note: O(n2) also covers linear time. ",
            "If we use Θ notation to represent the time complexity of Insertion sort, we have to use two statements for best and worst cases: ",
            "The Big-O notation is useful when we only have an upper bound on the time complexity of an algorithm. Many times we easily find an upper bound by simply looking at the algorithm.  ",
            " Examples :",
            "{ 100 , log (2000) , 10^4 } belongs to O(1)U { (n/4) , (2n+3) , (n/100 + log(n)) } belongs to O(n)U { (n^2+n) , (2n^2) , (n^2+log(n))} belongs to O( n^2) ",
            "Note: Here, U represents union, we can write it in these manner because O provides exact or upper bounds .",
            "Omega notation represents the lower bound of the running time of an algorithm. Thus, it provides the best case complexity of an algorithm.",
            "The execution time serves as a lower bound on the algorithm\u2019s time complexity.",
            "It is defined as the condition that allows an algorithm to complete statement execution in the shortest amount of time.",
            "Let g and f be the function from the set of natural numbers to itself. The function f is said to be Ω(g), if there is a constant c > 0 and a natural number n0 such that c*g(n) ≤ f(n) for all n ≥ n0",
            "Ω(g(n)) = { f(n): there exist positive constants c and n0 such that 0 ≤ cg(n) ≤ f(n) for all n ≥ n0 }",
            "Let us consider the same Insertion sort example here. The time complexity of Insertion Sort can be written as Ω(n), but it is not very useful information about insertion sort, as we are generally interested in worst-case and sometimes in the average case. ",
            "Examples :",
            "{ (n^2+n) , (2n^2) , (n^2+log(n))} belongs to Ω( n^2)U { (n/4) , (2n+3) , (n/100 + log(n)) } belongs to Ω(n)U { 100 , log (2000) , 10^4 } belongs to Ω(1)",
            "Note: Here, U represents union, we can write it in these manner because Ω provides exact or lower bounds.",
            "If f(n) is O(g(n)) then a*f(n) is also O(g(n)), where a is a constant.",
            "Example:",
            "f(n) = 2n²+5 is O(n²) then, 7*f(n) = 7(2n²+5) = 14n²+35 is also O(n²).",
            "Similarly, this property satisfies both Θ and Ω notation.",
            "We can say,",
            "If f(n) is Θ(g(n)) then a*f(n) is also Θ(g(n)), where a is a constant. If f(n) is Ω (g(n)) then a*f(n) is also Ω (g(n)), where a is a constant.",
            "If f(n) is O(g(n)) and g(n) is O(h(n)) then f(n) = O(h(n)).",
            "Example:",
            "If f(n) = n, g(n) = n² and h(n)=n³n is O(n²) and n² is O(n³) then, n is O(n³)",
            "Similarly, this property satisfies both Θ and Ω notation.",
            "We can say,",
            "If f(n) is Θ(g(n)) and g(n) is Θ(h(n)) then f(n) = Θ(h(n)) .If f(n) is Ω (g(n)) and g(n) is Ω (h(n)) then f(n) = Ω (h(n))",
            "Reflexive properties are always easy to understand after transitive.If f(n) is given then f(n) is O(f(n)). Since MAXIMUM VALUE OF f(n) will be f(n) ITSELF!Hence x = f(n) and y = O(f(n) tie themselves in reflexive relation always.",
            "Example:",
            "f(n) = n² ; O(n²) i.e O(f(n))Similarly, this property satisfies both Θ and Ω notation.   ",
            "We can say that,",
            "If f(n) is given then f(n) is Θ(f(n)).If f(n) is given then f(n) is Ω (f(n)).",
            "If f(n) is Θ(g(n)) then g(n) is Θ(f(n)).",
            "Example:",
            "If(n) = n² and g(n) = n²then, f(n) = Θ(n²) and g(n) = Θ(n²)",
            "This property only satisfies for Θ notation.",
            "If f(n) is O(g(n)) then g(n) is Ω (f(n)).",
            "Example:",
            "If(n) = n , g(n) = n²then n is O(n²) and n² is Ω (n) ",
            "This property only satisfies O and Ω notations.",
            "1. If f(n) = O(g(n)) and f(n) = Ω(g(n)) then f(n) = Θ(g(n))2. If f(n) = O(g(n)) and d(n)=O(e(n)) then f(n) + d(n) = O( max( g(n), e(n) )) ",
            "Example:",
            "f(n) = n i.e O(n) d(n) = n² i.e O(n²) then f(n) + d(n) = n + n² i.e O(n²)",
            "3. If f(n)=O(g(n)) and d(n)=O(e(n)) then f(n) * d(n) = O( g(n) * e(n))",
            "Example: ",
            "f(n) = n i.e O(n) d(n) = n² i.e O(n²)then f(n) * d(n) = n * n² = n³ i.e O(n³)_______________________________________________________________________________Note: If  f(n) = O(g(n)) then g(n) = Ω(f(n))  ",
            "Important Links :",
            "For more details, please refer: Design and Analysis of Algorithms."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:21.382333700",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Linked List - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 949,
        "pageId": "8155d124-c1c0-4dbc-a011-e9a1d0bd055a",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-linked-list-data-structure-and-algorithm-tutorial/?ref=outind",
        "content": [
            "A Linked List is a linear data structure which looks like a chain of nodes, where each node is a different element. Unlike Arrays, Linked List elements are not stored at a contiguous location. ",
            "It is basically chains of nodes, each node contains information such as data and a pointer to the next node in the chain. In the linked list there is a head pointer, which points to the first element of the linked list, and if the list is empty then it simply points to null or nothing.",
            "Linked List Tutorial",
            "Here are a few advantages of a linked list that is listed below, it will help you understand why it is necessary to know.",
            "There are mainly three types of linked lists:",
            "Traversal of items can be done in the forward direction only due to the linking of every node to its next node.",
            "Singly Linked List",
            "The following operations are performed on a Single Linked List",
            "Traversal of items can be done in both forward and backward directions as every node contains an additional prev pointer that points to the previous node.",
            "Doubly linked list",
            "A Node Creation:",
            "In a double-linked list, we perform the following operations\u2026",
            "A circular linked list is a type of linked list in which the first and the last nodes are also connected to each other to form a circle, there is no NULL at the end. ",
            "Circular Linked List",
            "The following operations are performed on a Circular Linked List",
            "Linked List vs. Array",
            "Here are some of the applications of a linked list:",
            "18",
            "Merge Sort for Linked Lists",
            "view",
            "solve",
            "Linked list are most commonly used to handle dynamic data elements. Linked list consists of nodes and a node consists of two fields one for storing data and other for keeping the reference of next node.",
            "A linked list can be assumed as a garland that is made up of flowers. Similarly, a linked list is made up of nodes. Every flower in this particular garland is referred to as a node. In addition, each node points to the next node in this list, and it contains data (in this case, the type of flower).",
            "There are some important advantages to using linked lists over other linear data structures. This is unlike arrays, as they are resizable at runtime. Additionally, they can be easily inserted and deleted.",
            "The linked list is a linear data structure that stores data in nodes. these nodes hold both the data and a reference to the next node in the list. Linked are very efficient at adding and removing nodes because of their simple structure.",
            "There are some following differences between them:",
            "Following are the reason that linked lists are preferred over array",
            "Following are some difference between single and double linked list.",
            "There are some advantages and disadvantages to both arrays and linked lists when it comes to storing linear data of similar types.",
            "Following are some limitations of the linked list:",
            "If any element is inserted/ deleted from the array, all the other elements after it will be shifted in memory this takes a lot of time whereas manipulation in Linked List is faster because we just need to manipulate the addresses of nodes, so no bit shifting is required in memory, and it will not take that much of time.",
            "There are many advantages of the linked list compared to array, despite the fact that they solve the similar problem to arrays, we have also discussed the advantage, disadvantages, and its application, and we concluded the fact that we can use a linked list if we need the dynamic size of storage and list are good for adding and removing items quickly or for tasks that require sequence but are not suitable for querying or search elements in a large collection of data.",
            "So, it becomes important that we should always keep in mind the positive and negative aspects of a data structure and how they relate to the problem you are trying to solve.",
            "Related articles:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:30.923751400",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Set \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 949,
        "pageId": "958a203b-c186-4815-a4d3-525dc7e1e295",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-set-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "DSA for Beginners\nLearn more about Sets in DSA Self Paced Course",
            "In computer science, a set data structure is defined as a data structure that stores a collection of distinct elements.It is a fundamental Data Structure that is used to store and manipulate a group of objects, where each object is unique. The Signature property of the set is that it doesn\u2019t allow duplicate elements.",
            "A set is a mathematical model for a collection of different things; a set contains elements or members, which can be mathematical objects of any kind numbers, symbols, points in space, lines, other geometrical shapes, variables, or even other sets.",
            "A set can be implemented in various ways but the most common ways are:",
            "Set data structures are commonly used in a variety of computer science applications, including algorithms, data analysis, and databases. The main advantage of using a set data structure is that it allows you to perform operations on a collection of elements in an efficient and organized way.",
            "The set data structure can be classified into the following two categories:",
            "An unordered set is an unordered associative container implemented using a hash table where keys are hashed into indices of a hash table so that the insertion is always randomized. All operations on the unordered set take constant time O(1) on an average which can go up to linear time O(n) in the worst case which depends on the internally used hash function, but practically they perform very well and generally provide a constant time lookup operation",
            "An Ordered set is the common set data structure we are familiar with. It is generally implemented using balanced BSTs and it supports O(log n) lookups, insertions and deletion operations.",
            "Sets in C++ internally implemented as (Self-Balancing Binary Search Tree)",
            "Sets in C++ STL are a type of associative container in which each element has to be unique because the value of the element identifies it. The values are stored in a specific sorted order, i.e., ascending or descending.",
            "The std::set class is the part of C++ Standard Template Library (STL) and it is defined inside the <set> header file.",
            "Types of set in C++ STL:",
            "1. set<int>st2. unordered_set<int>st3. multiset<int>st",
            "Syntax:",
            "Datatype: The set can take any data type depending on the values, e.g. int, char, float, etc.",
            "Sets in Java internally implemented as (Hash-Table)",
            "Set is an interface, objects cannot be created of the typeset. We always need a class that extends this list in order to create an object. And also, after the introduction of Generics in Java 1.5, it is possible to restrict the type of object that can be stored in the Set. This type-safe set can be defined as:",
            "Types of set in Java:",
            "1. HashSet2. TreeSet3. LinkedHashSet",
            "Syntax: ",
            "Sets in Python internally implemented as (Hash-Table)",
            "A Set in Python is an unordered collection data type that is iterable, mutable and has no duplicate elements. ",
            "Syntax: ",
            "Sets in C# internally implemented as (Hash-Table)",
            "Set in C# is an unordered collection of unique elements. It comes under System.Collections.Generic namespace. It is used in a situation where we want to prevent duplicates from being inserted in the collection. As far as performance is concerned, it is better in comparison to the list.",
            "Syntax: ",
            "Sets in JavaScript internally implemented as (Hash-Table)",
            "Set in JavaScript is a collection of items that are unique i.e. no element can be repeated. Set in ES6 are ordered: elements of the set can be iterated in the insertion order. A set can store any type of value whether primitive or objects.",
            "Syntax: ",
            "Example:",
            "array = [1,2,2,3,3,4,4,5] // Repeated values",
            "Set = set(array)",
            "SET(1,2,3,4,5) // only unique values",
            "A set is a data structure that stores a collection of unique elements, with no duplicates allowed. Sets can be implemented using a variety of data structures, including arrays, linked lists, binary search trees, and hash tables.",
            "Basically, a Set is language dependent Data Structure. Every language uses a different data structure to implement a set data structure internally like C++ uses Self-Balancing BST. Java, Python, C#, and JavaScript use Hash tables.",
            "Sets in C++ use Self-Balancing Binary Tree(BST). In this approach, the elements are stored in nodes of a binary tree, with the property that the left subtree of any node contains only elements smaller than the node\u2019s value, and the right subtree contains only elements larger than the node\u2019s value. This property ensures that the elements in the tree are always sorted in ascending order.",
            "Internal Implementation of Set Data Structure",
            "In the case of implementation of Set using Hash table (as happens in Python) the implementation happens in the following way:",
            "Here are some common operations that can be performed on a set data structure in C++ using the set container.",
            "You can insert an element into a set using the insert function. For example:",
            "Inserting Elements inside Set Data Structure",
            "For hash table implementations it will be like the following:",
            "Inserting Elements inside Set Data Structure",
            "You can check if an element is present in a set using the count function. The function returns 1 if the element is present, and 0 otherwise.",
            "You can remove an element from a set using the erase function. For example:",
            "Removing an Element from Set Data Structure",
            "In the case of Hash table implementation it will be like the following:",
            "Removing an Element from Set Data Structure",
            "You can find the minimum and maximum elements in a set using the begin and end iterators. The begin iterator points to the first element in the set, and the end iterator points to one past the last element.",
            "Taking out Maximum and Minimum from Set Data Structure",
            "In the case of hash table implementation in Python, the max() and min() functions return the maximum and the minimum respectively.",
            "You can get the size of a set using the size function. ",
            "Below is the Implementation of the above operations:",
            "Some Basic Operations/Terminologies Associated with Set Data Structure",
            "Below is the Implementation of above Operations/Terminologies Associated with Set Data Structure:",
            "Sets are abstract data types that can be used to store unique elements in a collection. Here are some common applications of sets:",
            "1. Find Union and Intersection of two unsorted arrays2. Count distinct elements in an array3. Longest Consecutive Subsequence4. Remove duplicates from sorted array5. K\u2019th Smallest/Largest Element in Unsorted Array",
            "In conclusion, sets are a good choice for algorithms that require unique elements, fast searching, and sorting, but they may not be the best choice for algorithms that require fast insertions, allow duplicates, or have memory constraints. The choice of data structure should depend on the specific requirements of the algorithm.",
            "I"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:34.529142900",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Asymptotic Notation and Analysis (Based on input size) in Complexity Analysis of Algorithms - GeeksforGeeks",
        "rating": 949,
        "pageId": "4ee8549d-41a6-4c56-b8b9-48d6cd428864",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/analysis-of-algorithms-set-1-asymptotic-analysis/?ref=outind",
        "content": [
            "Asymptotic Analysis is defined as the big idea that handles the above issues in analyzing algorithms. In Asymptotic Analysis, we evaluate the performance of an algorithm in terms of input size (we don\u2019t measure the actual running time). We calculate, how the time (or space) taken by an algorithm increases with the input size. ",
            "Asymptotic notation is a way to describe the running time or space complexity of an algorithm based on the input size. It is commonly used in complexity analysis to describe how an algorithm performs as the size of the input grows. The three most commonly used notations are Big O, Omega, and Theta.",
            "In general, the choice of asymptotic notation depends on the problem and the specific algorithm used to solve it. It is important to note that asymptotic notation does not provide an exact running time or space usage for an algorithm, but rather a description of how the algorithm scales with respect to input size. It is a useful tool for comparing the efficiency of different algorithms and for predicting how they will perform on large input sizes.",
            "There are many important things that should be taken care of, like user-friendliness, modularity, security, maintainability, etc. Why worry about performance?  The answer to this is simple, we can have all the above things only if we have performance. So performance is like currency through which we can buy all the above things. Another reason for studying performance is \u2013 speed is fun! To summarize, performance == scale. Imagine a text editor that can load 1000 pages, but can spell check 1 page per minute OR an image editor that takes 1 hour to rotate your image 90 degrees left OR \u2026 you get it. If a software feature can not cope with the scale of tasks users need to perform \u2013 it is as good as dead. ",
            "The way to study the efficiency of an algorithm is to implement it and experiment by running the program on various test inputs while recording the time spent during each execution. A simple mechanism in Java is based on use of the currentTimeMillis() method of the System class  for collecting such running times. That method reports the number of milliseconds that have passed since a benchmark time knownas the epoch (January 1, 1970 UTC).The key is that if we record the time immediately before executing the algorithm and then immediately after it.",
            "long start = System.currentTimeMillis( ); // record the starting time /∗ (run the algorithm) ∗/ long end = System.currentTimeMillis( ); // record the ending time long elapsed = end − start; //Total time elapsed",
            "Measuring elapsed time  provides a reasonable reflection of an algorithm\u2019s efficiency.",
            "One naive way of doing this is \u2013 to implement both the algorithms and run the two programs on your computer for different inputs and see which one takes less time. There are many problems with this approach for the analysis of algorithms. ",
            "Asymptotic Analysis is the big idea that handles the above issues in analyzing algorithms. In Asymptotic Analysis, we evaluate the performance of an algorithm in terms of input size (we don\u2019t measure the actual running time). We calculate, how the time (or space) taken by an algorithm increases with the input size. ",
            "For example, let us consider the search problem (searching a given item) in a sorted array. ",
            "The solution to above search problem includes: ",
            "To understand how Asymptotic Analysis solves the problems mentioned above in analyzing algorithms, ",
            "Running times for this example: ",
            "Experimental running times of two algorithms are difficult to directly compare unless the experiments are performed in the same hardware and software environments. Experiments can be done only on a limited set of test inputs; hence, they leave out the running times of inputs not included in the experiment (and these inputs may be important).",
            "To overcome the challenges in the Experimental analysis Asymptotic Analysis is used.",
            "Asymptotic Analysis is not perfect, but that\u2019s the best way available for analyzing algorithms. For example, say there are two sorting algorithms that take 1000nLogn and 2nLogn time respectively on a machine. Both of these algorithms are asymptotically the same (order of growth is nLogn). So, With Asymptotic Analysis, we can\u2019t judge which one is better as we ignore constants in Asymptotic Analysis. ",
            "Also, in Asymptotic analysis, we always talk about input sizes larger than a constant value. It might be possible that those large inputs are never given to your software and an asymptotically slower algorithm always performs better for your particular situation. So, you may end up choosing an algorithm that is Asymptotically slower but faster for your software.",
            "Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above",
            "Disadvantages:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:38.594757800",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Selection Sort \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 949,
        "pageId": "6620968a-4be3-4d01-a122-701bc3bb4ac5",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/selection-sort/?ref=outind",
        "content": [
            "Selection sort is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. ",
            "The algorithm repeatedly selects the smallest (or largest) element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted. ",
            "Lets consider the following array as an example: arr[] = {64, 25, 12, 22, 11}",
            "First pass:",
            "Selection Sort Algorithm | Swapping 1st element with the minimum in array",
            "Second Pass:",
            "Selection Sort Algorithm | swapping i=1 with the next minimum element",
            "Third Pass:",
            "Selection Sort Algorithm | swapping i=2 with the next minimum element",
            "Fourth pass:",
            "Selection Sort Algorithm | swapping i=3 with the next minimum element",
            "Fifth Pass:",
            "Selection Sort Algorithm | Required sorted array",
            "Below is the implementation of the above approach:",
            "Time Complexity: The time complexity of Selection Sort is O(N2) as there are two nested loops:",
            "Auxiliary Space: O(1) as the only extra memory used is for temporary variables while swapping two values in Array. The selection sort never makes more than O(N) swaps and can be useful when memory writing is costly. ",
            "Q1. Is Selection Sort Algorithm stable?",
            "The default implementation of the Selection Sort Algorithm is not stable. However, it can be made stable. Please see the stable Selection Sort for details.",
            "Q2. Is Selection Sort Algorithm in-place?",
            "Yes, Selection Sort Algorithm is an in-place algorithm, as it does not require extra space."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:39.161017200",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Bubble Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 949,
        "pageId": "017f36ef-b7d8-4301-a485-d26a5ebda640",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/bubble-sort/?ref=outind",
        "content": [
            "Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity is quite high.",
            "In Bubble Sort algorithm, ",
            "Let us understand the working of bubble sort with the help of the following illustration:",
            "Input: arr[] = {6, 3, 0, 5}",
            "First Pass: ",
            "The largest element is placed in its correct position, i.e., the end of the array.",
            "Bubble Sort Algorithm : Placing the largest element at correct position",
            "Second Pass: ",
            "Place the second largest element at correct position",
            "Bubble Sort Algorithm : Placing the second largest element at correct position",
            "Third Pass:",
            "Place the remaining two elements at their correct positions.",
            "Bubble Sort Algorithm : Placing the remaining elements at their correct positions",
            "Below is the implementation of the bubble sort. It can be optimized by stopping the algorithm if the inner loop didn\u2019t cause any swap. ",
            "Time Complexity: O(N2)Auxiliary Space: O(1)",
            "Bubble sort takes minimum time (Order of n) when elements are already sorted. Hence it is best to check if the array is already sorted or not beforehand, to avoid O(N2) time complexity.",
            "Yes, Bubble sort performs the swapping of adjacent pairs without the use of any major data structure. Hence Bubble sort algorithm is an in-place algorithm.",
            "Yes, the bubble sort algorithm is stable.",
            "Due to its simplicity, bubble sort is often used to introduce the concept of a sorting algorithm. In computer graphics, it is popular for its capability to detect a tiny error (like a swap of just two elements) in almost-sorted arrays and fix it with just linear complexity (2n). ",
            "Example: It is used in a polygon filling algorithm, where bounding lines are sorted by their x coordinate at a specific scan line (a line parallel to the x-axis), and with incrementing y their order changes (two elements are swapped) only at intersections of two lines.",
            "Related Articles: "
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:39.660341900",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Insertion Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 949,
        "pageId": "5ca31ef5-1df0-48d7-9b91-8c098a259f74",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/insertion-sort/?ref=outind",
        "content": [
            "Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.",
            "To sort an array of size N in ascending order iterate over the array and compare the current element (key) to its predecessor, if the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.",
            "Consider an example: arr[]: {12, 11, 13, 5, 6}",
            "First Pass:",
            "Second Pass:",
            "Third Pass:",
            "Fourth Pass:",
            "Illustrations:",
            " ",
            "Below is the implementation of the iterative approach:",
            "Time Complexity: O(N^2) Auxiliary Space: O(1)",
            "The auxiliary space complexity of Insertion Sort is O(1)",
            "Q1. What are the Boundary Cases of the Insertion Sort algorithm?",
            "Insertion sort takes the maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted. ",
            "Q2. What is the Algorithmic Paradigm of the Insertion Sort algorithm?",
            "The Insertion Sort algorithm follows an incremental approach.",
            "Q3. Is Insertion Sort an in-place sorting algorithm?",
            "Yes, insertion sort is an in-place sorting algorithm.",
            "Q4. Is Insertion Sort a stable algorithm?",
            "Yes, insertion sort is a stable sorting algorithm.",
            "Q5. When is the Insertion Sort algorithm used?",
            "Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, and only a few elements are misplaced in a complete big array."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:41.202891400",
        "images": [{
            "src": "https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/01/QuickSort2.png",
            "alt": "How Quicksort works"
        }],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "QuickSort - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 946,
        "pageId": "0360baef-de74-4277-86b0-06bb5b395843",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/quick-sort/?ref=outind",
        "content": [
            "QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.",
            "The key process in quickSort is a partition(). The target of partitions is to place the pivot (any element can be chosen to be a pivot) at its correct position in the sorted array and put all smaller elements to the left of the pivot, and all greater elements to the right of the pivot.",
            "Partition is done recursively on each side of the pivot after the pivot is placed in its correct position and this finally sorts the array.",
            "How Quicksort works",
            "There are many different choices for picking pivots. ",
            "The logic is simple, we start from the leftmost element and keep track of the index of smaller (or equal) elements as i. While traversing, if we find a smaller element, we swap the current element with arr[i]. Otherwise, we ignore the current element.",
            "Let us understand the working of partition and the Quick Sort algorithm with the help of the following example:",
            "Consider: arr[] = {10, 80, 30, 90, 40}.",
            "Partition in QuickSort: Compare pivot with 10",
            "Partition in QuickSort: Compare pivot with 80",
            "Partition in QuickSort: Compare pivot with 30",
            "Partition in QuickSort: Compare pivot with 90",
            "Partition in QuickSort: Place pivot in its correct position",
            "As the partition process is done recursively, it keeps on putting the pivot in its actual position in the sorted array. Repeatedly putting pivots in their actual position makes the array sorted.",
            "Follow the below images to understand how the recursive implementation of the partition algorithm helps to sort the array.",
            "Quicksort: Performing the partition",
            "Quicksort: Performing the partition",
            "Time Complexity:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:20.029385600",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Singly Linked List - GeeksforGeeks",
        "rating": 945,
        "pageId": "79582bdd-f0f3-4fb1-8173-e3c36ac45bdb",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/data-structures/linked-list/singly-linked-list/?ref=outind",
        "content": [
            "Learn more about Singly Linked List in DSA Self Paced Course\nPractice Problems on Singly Linked List",
            "A singly linked list is a linear data structure in which the elements are not stored in contiguous memory locations and each element is connected only to its next element using a pointer.",
            "Singly Linked List",
            "Topics:",
            "Introduction:",
            "Basic Operations:",
            "Some Problems on Singly Linked List:",
            "Quick Links :"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:36.936533900",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Worst, Average and Best Case Analysis of Algorithms - GeeksforGeeks",
        "rating": 945,
        "pageId": "02c95412-a91f-48c3-93f5-6a69609e21e4",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/analysis-of-algorithms-set-2-asymptotic-analysis/?ref=outind",
        "content": [
            "In the previous post, we discussed how Asymptotic analysis overcomes the problems of the naive way of analyzing algorithms. But let\u2019s take an overview of the asymptotic notation and learn about What is Worst, Average, and Best cases of an algorithm:",
            "We define an algorithm\u2019s worst-case time complexity by using the Big-O notation, which determines the set of functions grows slower than or at the same rate as the expression. Furthermore, it explains the maximum amount of time an algorithm requires to consider all input values.",
            "It defines the best case of an algorithm\u2019s time complexity, the Omega notation defines whether the set of functions will grow faster or at the same rate as the expression. Furthermore, it explains the minimum amount of time an algorithm requires to consider all input values.",
            "It defines the average case of an algorithm\u2019s time complexity, the Theta notation defines when the set of functions lies in both O(expression) and Omega(expression), then Theta notation is used. This is how we define a time complexity average case for an algorithm. ",
            "Based on the above three notations of Time Complexity there are three cases to analyze an algorithm:",
            "In the worst-case analysis, we calculate the upper bound on the running time of an algorithm. We must know the case that causes a maximum number of operations to be executed. For Linear Search, the worst case happens when the element to be searched (x) is not present in the array. When x is not present, the search() function compares it with all the elements of arr[] one by one. Therefore, the worst-case time complexity of the linear search would be O(n).",
            "In the best-case analysis, we calculate the lower bound on the running time of an algorithm. We must know the case that causes a minimum number of operations to be executed. In the linear search problem, the best case occurs when x is present at the first location. The number of operations in the best case is constant (not dependent on n). So time complexity in the best case would be Ω(1) ",
            "In average case analysis, we take all possible inputs and calculate the computing time for all of the inputs. Sum all the calculated values and divide the sum by the total number of inputs. We must know (or predict) the distribution of cases. For the linear search problem, let us assume that all cases are uniformly distributed (including the case of x not being present in the array). So we sum all the cases and divide the sum by (n+1). Following is the value of average-case time complexity.  ",
            "Average Case Time = \\sum_{i=1}^{n}\\frac{\\theta (i)}{(n+1)} = \\frac{\\theta (\\frac{(n+1)*(n+2)}{2})}{(n+1)} = \\theta (n)",
            "Below is the ranked mention of complexity analysis notation based on popularity:",
            "Most of the time, we do worst-case analyses to analyze algorithms. In the worst analysis, we guarantee an upper bound on the running time of an algorithm which is good information. ",
            "The average case analysis is not easy to do in most practical cases and it is rarely done. In the average case analysis, we must know (or predict) the mathematical distribution of all possible inputs. ",
            "The Best Case analysis is bogus. Guaranteeing a lower bound on an algorithm doesn\u2019t provide any information as in the worst case, an algorithm may take years to run.",
            "A) For some algorithms, all the cases (worst, best, average) are asymptotically the same. i.e., there are no worst and best cases. ",
            "B) Where as most of the other sorting algorithms have worst and best cases. ",
            "Time Complexity Analysis: (In Big-O notation)",
            "2. In this example, we will take an array of length (n) and deals with the following cases :",
            "Below is the implementation of the given problem:",
            "Time Complexity Analysis:",
            "For more details, please refer: Design and Analysis of Algorithms. Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above.",
            "Worst, Average, and Best Case Analysis of Algorithms is a technique used to analyze the performance of algorithms under different conditions. Here are some advantages, disadvantages, important points, and reference books related to this analysis technique:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:31.977387700",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Map \u2013 Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 944,
        "pageId": "e1b6bcef-0b41-435c-b608-74eaa26ce922",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-map-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "DSA for Beginners\nLearn more about Maps in DSA Self Paced Course",
            "Map data structure (also known as a dictionary, associative array, or hash map) is defined as a data structure that stores a collection of key-value pairs, where each key is associated with a single value. ",
            "Maps provide an efficient way to store and retrieve data based on a unique identifier (the key).",
            "The map data structure, also known as a dictionary, is used to store a collection of key-value pairs. It is an essential data structure in computer science because it allows for efficient and fast lookups, inserts, and deletes.",
            "Maps are widely used in many applications, including database indexing, network routing, and web programming. For example, in web programming, a map might be used to store a user\u2019s preferences, where the keys are the preferred names and the values are the preference values. In this case, the map provides a convenient way to store and retrieve user preferences without having to search through a list or array.",
            "There are several different types of maps or dictionary data structures used in computer science and data structures:",
            "A hash map is a data structure that uses a hash function to map keys to indices in an array. The hash function takes the key as input and produces an index into the array, where the corresponding value is stored. Hash maps have an average time complexity of O(1) for operations such as insertion and retrieval, making them one of the most efficient map data structures. However, hash collisions can occur when two keys map to the same index, leading to slower performance in the worst case.",
            "A tree map is a type of map that is implemented as a binary search tree. In a tree map, the keys are stored in a sorted order, allowing for efficient searching, insertion, and deletion operations. Tree maps have an average time complexity of O(log n) for operations such as insertion and retrieval, where n is the number of elements in the map.",
            "A linked hash map is a type of map that maintains a doubly-linked list of the entries in the map, in the order in which they were inserted. This allows for fast iteration over the elements in the map, as well as efficient insertion, retrieval, and deletion operations.",
            "A trie map, also known as a prefix tree, is a type of map that is used to store a set of strings, where each node in the tree represents a prefix of one or more strings. Tries are particularly useful for searching for strings that start with a given prefix, as the search can be terminated early once the prefix is not found in the trie.",
            "A bloom filter map is a type of map that uses a bloom filter, a probabilistic data structure, to determine whether a key is present in the map or not. Bloom filter maps are used when it is important to have a fast response time for key existence checks, but where the occasional false positive result is acceptable.",
            "Maps are associative containers that store elements in a mapped fashion. Each element has a key value and a mapped value. No two mapped values can have the same key values.",
            "Types of Maps in C++:",
            "Syntax:",
            "The map interface is present in java.util package represents a mapping between a key and a value. The Map interface is not a subtype of the Collection interface. Therefore it behaves a bit differently from the rest of the collection types.",
            "Types of Maps in Java:",
            "Syntax: ",
            "map() function returns a map object(which is an iterator) of the results after applying the given function to each item of a given iterable (list, tuple etc.)",
            "Syntax: ",
            "The Dictionary<TKey, TValue> Class in C# is a collection of Keys and Values. It is a generic collection class in the System.Collections.Generic namespace. The Dictionary <TKey, TValue> generic class provides a mapping from a set of keys to a set of values. Each addition to the dictionary consists of a value and its associated key.",
            "Map is a collection of elements where each element is stored as a Key, value pair. Map object can hold both objects and primitive values as either key or value. When we iterate over the map object it returns the key, value pair in the same order as inserted.",
            "Syntax: ",
            "Duplicate Values",
            "Unique Values",
            " keys are unique, but the values can be duplicated",
            "Ordered Collection",
            "Unordered Collection",
            "Unordered Collection",
            "Static",
            "Dynamic",
            "Dynamic",
            "Elements in an array can be accessed using their index",
            "Iterate over the set to retrieve the value.",
            "Elements can be retrieved using their key",
            "Adding, removing, and accessing elements",
            "Set operations like union, intersection, and difference.",
            "Maps are used for operations like adding, removing, and accessing key-value pairs.",
            "Stored as contiguous blocks of memory",
            "Implemented using linked lists or trees",
            "Implemented using linked lists or trees",
            "The Map data structure is a collection of key-value pairs that allows fast access to the values based on their corresponding keys. The internal implementation of the Map data structure depends on the programming language or library being used.",
            "Map data structure is typically implemented as an associative array or hash table, which uses a hash function to compute a unique index for each key-value pair. This index is then used to store and retrieve the value associated with that key.",
            "Map Data Structure",
            "When a new key-value pair is added to the Map, the hash function is applied to the key to compute its index, and the value is stored at that index. If there is already a value stored at that index, then the new value replaces the old one.",
            "In C++, an ordered map is implemented using the std::map container provided in the Standard Template Library (STL). The std::map is a templated container that stores key-value pairs in a sorted order based on the keys.",
            "Ordered Map",
            "Here is an example of how to declare an ordered map in C++:",
            "In C++, an unordered map is implemented using the std::unordered_map container provided in the Standard Template Library (STL). The std::unordered_map is a templated container that stores key-value pairs in an unordered manner based on the hash values of the keys.",
            "Unordered Map",
            "Here is an example of how to declare an unordered map in C++:",
            "A map is a data structure that allows you to store key-value pairs. Here are some common operations that you can perform with a map:",
            "Below is the Implementation of the above Operations:",
            "Here are some of the properties of the map data structure:",
            "1. Indexing and retrieval: Maps are used to index elements in an array and retrieve elements based on their keys.",
            "2. Grouping and categorization: Maps can be used to group elements and categorize them into different buckets. For example, you can group employees based on their departments, cities, or salary ranges.",
            "3. Network routing: Maps are used in computer networks to store information about routes between nodes. The information stored in the map can be used to find the shortest path between two nodes.",
            "4. Graph algorithms: Maps can be used to represent graphs and perform graph algorithms, such as depth-first search and breadth-first search.",
            "Time Complexity:",
            " ",
            "O(N)",
            "O(1)",
            "O(1)",
            "O(N)",
            "O(1)",
            "O(1)",
            "O(N)",
            "O(1)",
            "O(1)",
            "O(N)",
            "O(1)",
            "O(1)",
            "O(logN)",
            "O(logN)",
            "O(1)",
            "O(logN)",
            "O(logN)",
            "O(1)",
            "O(logN)",
            "O(logN)",
            "O(1)",
            "I"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:33.514060300",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Design and Analysis of Algorithms - GeeksforGeeks",
        "rating": 943,
        "pageId": "46b8bf04-a518-4e4b-8bdc-9eba4b84e07a",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/?ref=outind",
        "content": [
            "Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Analysis of algorithms is the determination of the amount of time and space resources required to execute it.",
            "Basics on Analysis of Algorithms:",
            "Asymptotic Notations:",
            "Some Advance topics:",
            "Complexity Proofs:",
            "If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.",
            "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:43.186279400",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Radix Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks",
        "rating": 941,
        "pageId": "0b95088e-c309-4770-93b4-7e7168eb3898",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/radix-sort/?ref=outind",
        "content": [
            "Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. ",
            "Rather than comparing elements directly, Radix Sort distributes the elements into buckets based on each digit\u2019s value. By repeatedly sorting the elements by their significant digits, from the least significant to the most significant, Radix Sort achieves the final sorted order.",
            "The key idea behind Radix Sort is to exploit the concept of place value. It assumes that sorting numbers digit by digit will eventually result in a fully sorted list. Radix Sort can be performed using different variations, such as Least Significant Digit (LSD) Radix Sort or Most Significant Digit (MSD) Radix Sort.",
            "To perform radix sort on the array [170, 45, 75, 90, 802, 24, 2, 66], we follow these steps:",
            "How does Radix Sort Algorithm work | Step 1",
            "Step 1: Find the largest element in the array, which is 802. It has three digits, so we will iterate three times, once for each significant place.",
            "Step 2: Sort the elements based on the unit place digits (X=0). We use a stable sorting technique, such as counting sort, to sort the digits at each significant place.",
            "Sorting based on the unit place:",
            "How does Radix Sort Algorithm work | Step 2",
            "Step 3: Sort the elements based on the tens place digits.",
            "Sorting based on the tens place:",
            "How does Radix Sort Algorithm work | Step 3",
            "Step 4: Sort the elements based on the hundreds place digits.",
            "Sorting based on the hundreds place:",
            "How does Radix Sort Algorithm work | Step 4",
            "Step 5: The array is now sorted in ascending order.",
            "The final sorted array using radix sort is [2, 24, 45, 66, 75, 90, 170, 802].",
            "How does Radix Sort Algorithm work | Step 5",
            "Below is the implementation for the above illustrations:",
            "Time Complexity: ",
            "Auxiliary Space: ",
            "Q1. Is Radix Sort preferable to Comparison based sorting algorithms like Quick-Sort? ",
            "If we have log2n bits for every digit, the running time of Radix appears to be better than Quick Sort for a wide range of input numbers. The constant factors hidden in asymptotic notation are higher for Radix Sort and Quick-Sort uses hardware caches more effectively. Also, Radix sort uses counting sort as a subroutine and counting sort takes extra space to sort numbers.",
            "Q2. What if the elements are in the range from 1 to n2?"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:27.161503",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Heap - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 940,
        "pageId": "dbe35fd8-f05d-4a81-84d5-9383b56a7aa9",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-heap-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A Heap is a special Tree-based Data Structure in which the tree is a complete binary tree.",
            "Generally, heaps are of two types.",
            "In this heap, the value of the root node must be the greatest among all its child nodes and the same thing must be done for its left and right sub-tree also.",
            "The total number of comparisons required in the max heap is according to the height of the tree. The height of the complete binary tree is always logn; therefore, the time complexity would also be O(logn).",
            "In this heap, the value of the root node must be the smallest among all its child nodes and the same thing must be done for its left and right sub-tree also.",
            "The total number of comparisons required in the min heap is according to the height of the tree. The height of the complete binary tree is always logn; therefore, the time complexity would also be O(logn).",
            " ",
            "Operations supported by min \u2013 heap and max \u2013 heap are same. The difference is just that min-heap contains minimum element at root of the tree and max \u2013 heap contains maximum element at the root of the tree.",
            "It is the process to rearrange the elements to maintain the property of heap data structure. It is done when a certain node creates an imbalance in the heap due to some operations on that node. It takes O(log N) to balance the tree. ",
            "This operation also takes O(logN) time.",
            "Examples:",
            "Assume initially heap(taking max-heap) is as follows",
            "           8        /   \\     4     5   / \\1   2",
            "Now if we insert 10 into the heap             8        /      \\      4       5   /  \\      /1    2  10 ",
            "After heapify operation final heap will be look like this           10         /    \\      4      8   /  \\     /1    2  5",
            "It takes O(logN) time.",
            "Example:",
            "Assume initially heap(taking max-heap) is as follows           15         /   \\      5     7   /  \\2     3",
            "Now if we delete 15 into the heap it will be replaced by leaf node of the tree for temporary.           3        /   \\     5     7   /    2",
            "After heapify operation final heap will be look like this           7        /   \\     5     3   /   2",
            "It finds the maximum element or minimum element for max-heap and min-heap respectively and as we know minimum and maximum elements will always be the root node itself for min-heap and max-heap respectively. It takes O(1) time.",
            "This operation returns and deletes the maximum element and minimum element from the max-heap and min-heap respectively. In short, it deletes the root element of the heap binary tree.",
            "The following code shows the implementation of a max-heap.",
            "Let\u2019s understand the maxHeapify function in detail:-",
            "maxHeapify is the function responsible for restoring the property of the Max Heap. It arranges the node i, and its subtrees accordingly so that the heap property is maintained."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:37.764246",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Binary Search - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 940,
        "pageId": "e80a8bae-ed06-4cfa-9742-051f1ad11352",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/binary-search/?ref=outind",
        "content": [
            "Binary Search is defined as a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log N). ",
            "Example of Binary Search Algorithm",
            "To apply Binary Search algorithm:",
            "In this algorithm, ",
            "Finding the middle index \u201cmid\u201d in Binary Search Algorithm",
            "To understand the working of binary search, consider the following illustration:",
            "Consider an array arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}, and the target = 23.",
            "First Step: Calculate the mid and compare the mid element with the key. If the key is less than mid element, move to left and if it is greater than the mid then move search space to the right.",
            "Binary Search Algorithm : Compare key with 16",
            "Binary Search Algorithm : Compare key with 56",
            "Second Step: If the key matches the value of the mid element, the element is found and stop search.",
            "Binary Search Algorithm : Key matches with mid",
            "The Binary Search Algorithm can be implemented in the following two ways",
            "Given below are the pseudocodes for the approaches.",
            "Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves.",
            "Implementation of Iterative  Binary Search Algorithm: ",
            "Time Complexity: O(log N)Auxiliary Space: O(1)",
            "Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space.",
            "Implementation of Recursive  Binary Search Algorithm:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:37.271815",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Linear Search Algorithm - Data Structure and Algorithms Tutorials - GeeksforGeeks",
        "rating": 939,
        "pageId": "d2c3f845-1923-43f9-a44d-929dfaddd71d",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/linear-search/?ref=outind",
        "content": [
            "Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set.",
            "Linear Search Algorithm",
            "In Linear Search Algorithm, ",
            "For example: Consider the array arr[] = {10, 50, 30, 70, 80, 20, 90, 40} and key = 30",
            "Step 1: Start from the first element (index 0) and compare key with each element (arr[i]).",
            "Compare key with arr[0]",
            "Compare key with arr[1]",
            "Step 2: Now when comparing arr[2] with key, the value matches. So the Linear Search Algorithm will yield a successful message and return the index of the element when key is found (here 2).",
            "Compare key with arr[2]",
            "Below is the implementation of the linear search algorithm:",
            "Time Complexity:",
            "Auxiliary Space: O(1) as except for the variable to iterate through the list, no other variable is used. "
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:26.673897600",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 936,
        "pageId": "7f1cf6ef-c674-43cd-9594-242854eb26f6",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A tree data structure is a hierarchical structure that is used to represent and organize data in a way that is easy to navigate and search. It is a collection of nodes that are connected by edges and has a hierarchical relationship between the nodes. ",
            "The topmost node of the tree is called the root, and the nodes below it are called the child nodes. Each node can have multiple child nodes, and these child nodes can also have their own child nodes, forming a recursive structure.",
            "This data structure is a specialized method to organize and store data in the computer to be used more effectively. It consists of a central node, structural nodes, and sub-nodes, which are connected via edges. We can also say that tree data structure has roots, branches, and leaves connected with one another.",
            "Introduction to Tree \u2013 Data Structure and Algorithm Tutorials",
            "A tree consists of a root, and zero or more subtrees T1, T2, \u2026 , Tk such that there is an edge from the root of the tree to the root of each subtree.",
            "Representation of Tree Data Structure",
            "struct Node{   int data;   struct Node *first_child;   struct Node *second_child;   struct Node *third_child;   .   .   .   struct Node *nth_child;};",
            " ",
            "Here,",
            "To learn more about types of trees, refer to this article.",
            "The data in a tree are not stored in a sequential manner i.e., they are not stored linearly. Instead, they are arranged on multiple levels or we can say it is a hierarchical structure. For this reason, the tree is considered to be a non-linear data structure.",
            "1. One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: ",
            "File System",
            "2. Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays). 3. Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists). 4. Like Linked Lists and unlike Arrays, Trees don\u2019t have an upper limit on the number of nodes as nodes are linked using pointers.",
            "To learn more about the applications of Tree Data Structure, refer to this article.",
            "To learn more about the advantages of Tree Data Structure, refer to this article.",
            "To learn more about the disadvantages of Tree Data Structure, refer to this article."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:21.787863300",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Stack - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 934,
        "pageId": "14f455a8-ed49-48b2-a94e-ce12e09d0332",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-stack-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A stack is a linear data structure in which the insertion of a new element and removal of an existing element takes place at the same end represented as the top of the stack.",
            "To implement the stack, it is required to maintain the pointer to the top of the stack, which is the last element to be inserted because we can access the elements only on the top of the stack.",
            "LIFO( Last In First Out ):",
            "This strategy states that the element that is inserted last will come out first. You can take a pile of plates kept on top of each other as a real-life example. The plate which we put last is on the top and since we remove the plate that is at the top, we can say that the plate that was put last comes out first.",
            "In order to make manipulations in a stack, there are certain operations provided to us.",
            "Stack",
            "Adds an item to the stack. If the stack is full, then it is said to be an Overflow condition.",
            "Algorithm for push:",
            "Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.",
            "Algorithm for pop:",
            "Returns the top element of the stack.",
            "Algorithm for Top:",
            "Returns true if the stack is empty, else false.",
            "Algorithm for isEmpty:",
            "There are many real-life examples of a stack. Consider the simple example of plates stacked over one another in a canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow the LIFO/FILO order.",
            "In addition to these two main types, there are several other variations of Stacks, including:",
            "A stack can be implemented using an array or a linked list. In an array-based implementation, the push operation is implemented by incrementing the index of the top element and storing the new element at that index. The pop operation is implemented by decrementing the index of the top element and returning the value stored at that index. In a linked list-based implementation, the push operation is implemented by creating a new node with the new element and setting the next pointer of the current top node to the new node. The pop operation is implemented by setting the next pointer of the current top node to the next node and returning the value of the current top node.",
            "Stacks are commonly used in computer science for a variety of applications, including the evaluation of expressions, function calls, and memory management. In the evaluation of expressions, a stack can be used to store operands and operators as they are processed. In function calls, a stack can be used to keep track of the order in which functions are called and to return control to the correct function when a function returns. In memory management, a stack can be used to store the values of the program counter and the values of the registers in a computer program, allowing the program to return to the previous state when a function returns.",
            "In conclusion, a Stack is a linear data structure that operates on the LIFO principle and can be implemented using an array or a linked list. The basic operations that can be performed on a stack include push, pop, and peek, and stacks are commonly used in computer science for a variety of applications, including the evaluation of expressions, function calls, and memory management.There are two ways to implement a stack \u2013",
            "Related Articles:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:40.494837800",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Merge Sort - Data Structure and Algorithms Tutorials - GeeksforGeeks",
        "rating": 931,
        "pageId": "245ef59b-0bd7-4a61-a2a1-249cac6e1798",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/merge-sort/?ref=outind",
        "content": [
            "Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array.",
            "In simple terms, we can say that the process of merge sort is to divide the array into two halves, sort each half, and then merge the sorted halves back together. This process is repeated until the entire array is sorted.",
            "Merge Sort Algorithm",
            "Merge sort is a recursive algorithm that continuously splits the array in half until it cannot be further divided i.e., the array has only one element left (an array with one element is always sorted). Then the sorted subarrays are merged into one sorted array.",
            "See the below illustration to understand the working of merge sort.",
            "Illustration:",
            "Lets consider an array arr[] = {38, 27, 43, 10}",
            "Merge Sort: Divide the array into two halves",
            "Merge Sort: Divide the subarrays into two halves (unit length subarrays here)",
            "These sorted subarrays are merged together, and we get bigger sorted subarrays.",
            "Merge Sort: Merge the unit length subarrys into sorted subarrays",
            "This merging process is continued until the sorted array is built from the smaller subarrays.",
            "Merge Sort: Merge the sorted subarrys to get the sorted array",
            "The following diagram shows the complete merge sort process for an example array {38, 27, 43, 10}. ",
            "Below is the Code implementation of Merge Sort.",
            "Time Complexity: O(N log(N)),  Merge Sort is a recursive algorithm and time complexity can be expressed as following recurrence relation. ",
            "T(n) = 2T(n/2) + θ(n)",
            "The above recurrence can be solved either using the Recurrence Tree method or the Master method. It falls in case II of the Master Method and the solution of the recurrence is θ(Nlog(N)). The time complexity of Merge Sort isθ(Nlog(N)) in all 3 cases (worst, average, and best) as merge sort always divides the array into two halves and takes linear time to merge two halves.",
            "Auxiliary Space: O(N), In merge sort all elements are copied into an auxiliary array. So N auxiliary space is required for merge sort.",
            "Quick Links:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:19.882766200",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Strings - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 925,
        "pageId": "b7d3ca30-c72f-4e95-a120-b320b0560eb4",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-strings-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "Strings are considered a data type in general and are typically represented as arrays of bytes (or words) that store a sequence of characters. Strings are defined as an array of characters. The difference between a character array and a string is the string is terminated with a special character \u2018\\0\u2019",
            "Complete Guide to String interview preparation",
            "Below are some examples of strings:",
            "\u201cgeeks\u201d , \u201cfor\u201d, \u201cgeeks\u201d, \u201cGeeksforGeeks\u201d, \u201cGeeks for Geeks\u201d, \u201c123Geeks\u201d, \u201c@123 Geeks\u201d",
            "In C, a string can be referred to either using a character pointer or as a character array. When strings are declared as character arrays, they are stored like other types of arrays in C. For example, if str[] is an auto variable then the string is stored in the stack segment, if it\u2019s a global or static variable then stored in the data segment, etc.",
            "Representation of String",
            "Below is the representation of strings in various languages:",
            "Here we are providing you with some must-know concepts of string:",
            "The process of combining more than one string together is known as Concatenation. String Concatenation is the technique of combining two strings. ",
            "Concatenation of Strings",
            "There are two ways to concatenate two strings:",
            "Below is the algorithm for the Concatenation of two strings:",
            "Algorithm: CONCATENATE (STR1, STR2, STR3)",
            "A very basic operation performed on Strings is to find something in the given whole string. Now, this can be to find a given character in a string, or to find a complete string in another string.",
            "Find in String",
            "Given a string and a character, your task is to find the first position of the character in the string. These types of problems are very competitive programming where you need to locate the position of the character in a string.",
            "Consider there to be a string of length N and a substring of length M. Then run a nested loop, where the outer loop runs from 0 to (N-M) and the inner loop from 0 to M. For every index check if the sub-string traversed by the inner loop is the given sub-string or not. ",
            "An efficient solution is to use a O(n) searching algorithm like KMP algorithm, Z algorithm, etc.",
            "Language implementations: ",
            "Many times, it is very important to make corrections in strings. Replacing a character, word or phrase in a String is another very common operation performed on Strings.",
            "The simplest approach to solve the given problem is to traverse the string S and when any string S1 is found as a substring in the string S then replace it by S2. Follow the steps below to solve this problem:",
            "One of the most general operations on String is to find the length/size of a given string. Length is defined as the number of characters in a string is called the length of that string.",
            "Finding the Length of String",
            "There are two ways to concatenate two strings:",
            "Below is the algorithm for finding the length of two strings:",
            "Spaces or special characters are very common in Strings. So it is important to know how to trim such characters in String.",
            "Below is a Simple Solution ",
            "1) Iterate through all characters of given string, do following   a) If current character is a space, then move all subsequent characters one position back and decrease length of the result string.",
            "The time complexity of the above solution is O(n2).",
            "A Better Solution can solve it in O(n) time. The idea is to keep track of count of non-space character seen so far. ",
            "1) Initialize \u2018count\u2019 = 0 (Count of non-space character seen so far)2) Iterate through all characters of given string, do following     a) If current character is non-space, then put this character at index \u2018count\u2019 and increment \u2018count\u20193) Finally, put \u2018\\0\u2019 at index \u2018count\u2019",
            "Reverse operation is interchanging the position of characters of a string such that the first becomes the last, the second becomes the second last, and so on.",
            "Rotation of a String",
            "Consider a string \u201cgeeks\u201d, now all possible rotations for this will be:",
            "The reversing of a string is nothing but simply substituting the last element of a string to the 1st position of the string.",
            "A subsequence is a sequence that can be derived from another sequence by removing zero or more elements, without changing the order of the remaining elements.",
            "More generally, we can say that for a sequence of size n, we can have (2n-1) non-empty sub-sequences in total.",
            "For example, Consider the string \u201cgeeks\u201d, there are 15 sub-sequences. They are:",
            "A substring is a contiguous part of a string, i.e., a string inside another string.",
            "In general, for a string of size n, there are n*(n+1)/2 non-empty substrings.",
            "For example, Consider the string \u201cgeeks\u201d, There are 15 non-empty substrings.The subarrays are:",
            "A Binary String is a special kind of string made up of only two types of characters, such as 0 and 1.For Example:  ",
            "A string is said to be a palindrome if the reverse of the string is the same as the string. For example,",
            "Lexicographical pattern is the pattern based on the ASCII value or can be said in dictionary order. We consider the lexicographic order of characters as their order of ASCII value. Hence the lexicographical order of characters will be ",
            "Pattern searching is searching a given pattern in the string. It is an advanced topic of string. The Pattern Searching algorithms are sometimes also referred to as String Searching Algorithms and are considered as a part of the String algorithms. These algorithms are useful in the case of searching a string within another string.",
            "Pattern Searching",
            "Easy Problems on String",
            " ",
            "Medium Problems on String",
            " ",
            "Hard Problems on String",
            "Yes, string is a linear data structure.",
            "It is used to store the sequence of characters.",
            "A string is generally considered a data type and is often implemented as an array data structure of bytes (or words) that stores a sequence of elements, typically characters, using some character encoding.",
            "Text are also called string because it consists of sequence of characters like string.",
            "Each digit in a string is a character and character is a single visual object used to represent text, numbers, or symbols.",
            "After the discussion, we concluded that Strings are a simple method to store some textual information and Strings are an array of characters that terminate with a null character \u2018\\0\u2019. The difference between a character array and a string is that, unlike the character array, the string ends with a null character. Apart from this we have also discussed Top theoretical interview questions as well as Top 50 interview coding question on string which will help you to tackle interview problems.",
            "Related articles:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:24.688877600",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction of B-Tree - GeeksforGeeks",
        "rating": 925,
        "pageId": "c3a644c1-27c2-427f-adcc-8aac6319a733",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-of-b-tree-2/?ref=outind",
        "content": [
            "The limitations of traditional binary search trees can be frustrating. Meet the B-Tree, the multi-talented data structure that can handle massive amounts of data with ease. When it comes to storing and searching large amounts of data, traditional binary search trees can become impractical due to their poor performance and high memory usage. B-Trees, also known as B-Tree or Balanced Tree, are a type of self-balancing tree that was specifically designed to overcome these limitations.",
            "Unlike traditional binary search trees, B-Trees are characterized by the large number of keys that they can store in a single node, which is why they are also known as \u201clarge key\u201d trees. Each node in a B-Tree can contain multiple keys, which allows the tree to have a larger branching factor and thus a shallower height. This shallow height leads to less disk I/O, which results in faster search and insertion operations. B-Trees are particularly well suited for storage systems that have slow, bulky data access such as hard drives, flash memory, and CD-ROMs.",
            "B-Trees maintains balance by ensuring that each node has a minimum number of keys, so the tree is always balanced. This balance guarantees that the time complexity for operations such as insertion, deletion, and searching is always O(log n), regardless of the initial shape of the tree.",
            "Note: \u201cn\u201d is the total number of elements in the B-tree",
            "Following is an example of a B-Tree of minimum order 5 Note: that in practical B-Trees, the value of the minimum order is much more than 5.  ",
            "We can see in the above diagram that all the leaf nodes are at the same level and all non-leafs have no empty sub-tree and have keys one less than the number of their children.",
            "Traversal is also similar to Inorder traversal of Binary Tree. We start from the leftmost child, recursively print the leftmost child, then repeat the same process for the remaining children and keys. In the end, recursively print the rightmost child. ",
            "Search is similar to the search in Binary Search Tree. Let the key to be searched is k. ",
            "Searching a B-Tree is similar to searching a binary tree. The algorithm is similar and goes with recursion. At each level, the search is optimized as if the key value is not present in the range of the parent then the key is present in another branch. As these values limit the search they are also known as limiting values or separation values. If we reach a leaf node and don\u2019t find the desired key then it will display NULL.",
            "Examples: ",
            "Input: Search 120 in the given B-Tree.  ",
            " Solution:  ",
            " ",
            " ",
            "In this example, we can see that our search was reduced by just limiting the chances where the key containing the value could be present. Similarly if within the above example we\u2019ve to look for 180, then the control will stop at step 2 because the program will find that the key 180 is present within the current node. And similarly, if it\u2019s to seek out 90 then as 90 < 100 so it\u2019ll go to the left subtree automatically, and therefore the control flow will go similarly as shown within the above example.",
            "Below is the implementation of the above approach:",
            "Note: The above code doesn\u2019t contain the driver program. We will be covering the complete program in our next post on B-Tree Insertion.",
            "There are two conventions to define a B-Tree, one is to define by minimum degree, second is to define by order. We have followed the minimum degree convention and will be following the same in coming posts on B-Tree. The variable names used in the above program are also kept the same",
            "Insertion and Deletion:B-Tree Insertion B-Tree Deletion",
            "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:29.727251800",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Graphs - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 924,
        "pageId": "dfeccb13-efd3-4e97-b68f-a74493486f9a",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-graphs-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A Graph is a non-linear data structure consisting of vertices and edges. The vertices are sometimes also referred to as nodes and the edges are lines or arcs that connect any two nodes in the graph. More formally a Graph is composed of a set of vertices( V ) and a set of edges( E ). The graph is denoted by G(V, E).",
            "Graph data structures are a powerful tool for representing and analyzing complex relationships between objects or entities. They are particularly useful in fields such as social network analysis, recommendation systems, and computer networks. In the field of sports data science, graph data structures can be used to analyze and understand the dynamics of team performance and player interactions on the field.",
            "Imagine a game of football as a web of connections, where players are the nodes and their interactions on the field are the edges. This web of connections is exactly what a graph data structure represents, and it\u2019s the key to unlocking insights into team performance and player dynamics in sports.",
            "A graph is known as a null graph if there are no edges in the graph.",
            "Graph having only a single vertex, it is also the smallest graph possible.",
            " ",
            "A graph in which edges do not have any direction. That is the nodes are unordered pairs in the definition of every edge. ",
            "A graph in which edge has direction. That is the nodes are ordered pairs in the definition of every edge.",
            "The graph in which from one node we can visit any other node in the graph is known as a connected graph. ",
            "The graph in which at least one node is not reachable from a node is known as a disconnected graph.",
            "The graph in which the degree of every vertex is equal to K is called K regular graph.",
            "The graph in which from each node there is an edge to each other node.",
            ".",
            "The graph in which the graph is a cycle in itself, the degree of each vertex is 2. ",
            "A graph containing at least one cycle is known as a Cyclic graph.",
            "A Directed Graph that does not contain any cycle. ",
            "A graph in which vertex can be divided into two sets such that vertex in each set does not contain any edge between them.",
            "13. Weighted Graph",
            "          ",
            "Trees are the restricted types of graphs, just with some more rules. Every tree will always be a graph but not all graphs will be trees. Linked List, Trees, and Heaps all are special cases of graphs. ",
            "There are two ways to store a graph:",
            "In this method, the graph is stored in the form of the 2D matrix where rows and columns denote vertices. Each entry in the matrix represents the weight of the edge between those vertices. ",
            "This graph is represented as a collection of linked lists. There is an array of pointer which points to the edges connected to that vertex. ",
            "When the graph contains a large number of edges then it is good to store it as a matrix because only some entries in the matrix will be empty. An algorithm such as Prim\u2019s and Dijkstra adjacency matrix is used to have less complexity.",
            "Below are the basic operations on the graph:",
            "    ",
            "However, there are also some scenarios where using a graph may not be the best approach. For example, if the data being represented is very simple or structured, a graph may be overkill and a simpler data structure may suffice. Additionally, if the graph is very large or complex, it may be difficult or computationally expensive to analyze or traverse, which could make using a graph less desirable."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:20.932863900",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Insertion in Doubly Circular Linked List - GeeksforGeeks",
        "rating": 923,
        "pageId": "168cf80b-a328-434f-a831-bef3504a9fd3",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/doubly-circular-linked-list-set-1-introduction-and-insertion/?ref=outind",
        "content": [
            "Circular Doubly Linked List has properties of both doubly linked list and circular linked list in which two consecutive elements are linked or connected by the previous and next pointer and the last node points to the first node by the next pointer and also the first node points to the last node by the previous pointer.",
            "Following is the representation of a Circular doubly linked list node in C/C++: ",
            " ",
            "Circular Doubly Linked LIst",
            "A node(Say N) is inserted with data = 5. So, the previous pointer of N points to N and the next pointer of N also points to N. But now start pointer points to the first node of the list.",
            "Insertion in an empty list",
            "A node(Say M) is inserted with data = 7, so the previous pointer of M points to the last node, the next pointer of M points to the first node and the last node\u2019s next pointer points to this M node, and first node\u2019s previous pointer points to this M node.",
            "Insertion at the end of list",
            "Below is the implementation of the above operations:",
            "To insert a node at the beginning of the list, create a node(Say T) with data = 5, T next pointer points to the first node of the list, T previous pointer points to the last node of the list, last node\u2019s next pointer points to this T node, first node\u2019s previous pointer also points this T node and at last don\u2019t forget to shift \u2018Start\u2019 pointer to this T node.",
            "Insertion at the beginning of the list",
            "Below is the implementation of the above operation:",
            "To insert a node in between the list, two data values are required one after which new node will be inserted and another is the data of the new node.",
            "Insertion in between other nodes",
            "Below is the implementation of the above operation:",
            "Following is a complete program that uses all of the above methods to create a circular doubly linked list.  ",
            "Time Complexity: O(N)Auxiliary Space: O(1), As constant extra space is used.",
            "This article is contributed by Akash Gupta. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.",
            "A"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:22.241382800",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Queue - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 919,
        "pageId": "69f6f4c6-6fee-4172-83d2-5b7c910acb2a",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A queue is a linear data structure that is open at both ends and the operations are performed in First In First Out (FIFO) order.",
            "We define a queue to be a list in which all additions to the list are made at one end, and all deletions from the list are made at the other end.  The element which is first pushed into the order, the delete operation is first performed on that.",
            "FIFO property of queue",
            "Like stacks, Queues can also be represented in an array: In this representation, the Queue is implemented using the array. Variables used in this case are",
            "Array representation of queue:",
            "A queue can also be represented using following entities:",
            "There are different types of queues:",
            "To learn more about different types of queues, read the article on \u201cTypes of Queues\u201c.",
            "Some of the basic operations for Queue in Data Structure are:",
            "There are a few supporting operations (auxiliary operations):",
            "Enqueue() operation in Queue adds (or stores) an element to the end of the queue.The following steps should be taken to enqueue (insert) data into a queue:",
            "Enqueue representation",
            "Implementation of Enqueue:",
            "Removes (or access) the first element from the queue.The following steps are taken to perform the dequeue operation:",
            "Dequeue operation",
            "Implementation of dequeue:",
            "This operation returns the element at the front end without removing it.",
            "This operation returns the element at the rear end without removing it.",
            "This operation returns a boolean value that indicates whether the queue is empty or not.",
            "This operation returns a boolean value that indicates whether the queue is full or not.",
            "Queue can be implemented using following data structures:",
            "We have discussed the Structure implementation of Queue below:",
            "Time complexity: All the operations have O(1) time complexity.Auxiliary Space: O(N) ",
            "Application of queue is common. In a computer system, there may be queues of tasks waiting for the printer, for access to disk storage, or even in a time-sharing system, for use of the CPU. Within a single program, there may be multiple requests to be kept in a queue, or one task may create other tasks, which must be done in turn by keeping them in a queue.",
            "Priority queues can be implemented using a variety of data structures, including linked lists, arrays, binary search trees, and heaps. Priority queues are best implemented using the heap data structure.",
            "In addition to making your data persistent, queues reduce errors that occur when different parts of your system are down.",
            "In a double-ended queue, elements can be inserted and removed at both ends.",
            "If you want things to come out in the order you put them in, use a queue. Stacks are useful when you want to reorder things after putting them in. ",
            "Related articles:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:20.277591500",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Insertion in a Doubly Linked List - GeeksforGeeks",
        "rating": 918,
        "pageId": "46e5e964-0494-41f7-9861-b400e0d5f27f",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/doubly-linked-list/?ref=outind",
        "content": [
            "Inserting a new node in a doubly linked list is very similar to inserting new node in linked list. There is a little extra work required to maintain the link of the previous node. A node can be inserted in a Doubly Linked List in four ways:",
            "The new node is always added before the head of the given Linked List. The task can be performed by using the following 5 steps:",
            "Illustration:",
            "See the below illustration where E is being inserted at the beginning of the doubly linked list.",
            "Below is the implementation of the 5 steps to insert a node at the front of the linked list:",
            "Time Complexity: O(1)Auxiliary Space: O(1)",
            "It is further classified into the following two parts:",
            "We are given a pointer to a node as prev_node, and the new node is inserted after the given node. This can be done using the following 6 steps:",
            "Illustration:",
            "See the below illustration where \u2018E\u2018 is being inserted after \u2018B\u2018.",
            "Below is the implementation of the 7 steps to insert a node after a given node in the linked list:",
            "Time Complexity: O(1)Auxiliary Space: O(1)",
            "Let the pointer to this given node be next_node. This can be done using the following 6 steps. ",
            "Illustration:",
            "See the below illustration where \u2018B\u2018 is being inserted before \u2018C\u2018.",
            "Below is the implementation of the above approach.",
            "Time Complexity: O(1)Auxiliary Space: O(1)",
            "The new node is always added after the last node of the given Linked List. This can be done using the following 7 steps:",
            "Illustration:",
            "See the below illustration where \u2018D\u2018 is inserted at the end of the linked list.",
            "Below is the implementation of the 7 steps to insert a node at the end of the linked list:",
            "Time Complexity: O(n)Auxiliary Space: O(1)",
            "Related Articles:",
            "Please write comments if you find anything incorrect, or if you want to share more information about the topic discussed above. "
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:22.628539900",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Generic Trees (N-ary Trees) - GeeksforGeeks",
        "rating": 913,
        "pageId": "ce923a21-f95e-4dbf-b223-1ae0f510cd5d",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/generic-treesn-array-trees/?ref=outind",
        "content": [
            "Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children(duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes. Every node stores address of its children and the very first node\u2019s address will be stored in a separate pointer called root.",
            "The Generic trees are the N-ary trees which have the following properties: ",
            "            1. Many children at every node.",
            "            2. The number of nodes for each node is not known in advance.",
            "Example:  ",
            "Generic Tree",
            "To represent the above tree, we have to consider the worst case, that is the node with maximum children (in above example, 6 children) and allocate that many pointers for each node.The node representation based on this method can be written as: ",
            "Disadvantages of the above representation are: ",
            "Simple Approach: ",
            "For storing the address of children in a node we can use an array or linked list. But we will face some issues with both of them.",
            "Better Approach:",
            "We can use Dynamic Arrays for storing the address of children. We can randomly access any child\u2019s address and the size of the vector is also not fixed.",
            "First child / Next sibling representation",
            " In the first child/next sibling representation, the steps taken are: ",
            "At each node-link the children of the same parent(siblings) from left to right.",
            "Since we have a link between children, we do not need extra links from parents to all the children. This representation allows us to traverse all the elements by starting at the first child of the parent. ",
            "FIRST CHILD/NEXT SIBLING REPRESENTATION",
            "The node declaration for first child / next sibling representation can be written as:  ",
            "Advantages: ",
            "Height of generic tree from parent array Generic tree \u2013 level order traversal",
            "S"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:20.661187700",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Circular Linked List - GeeksforGeeks",
        "rating": 912,
        "pageId": "d9d0cb0e-8d25-4ee3-bcf5-651b675c9ecc",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/circular-linked-list/?ref=outind",
        "content": [
            "The circular linked list is a linked list where all nodes are connected to form a circle. In a circular linked list, the first node and the last node are connected to each other which forms a circle. There is no NULL at the end.",
            " ",
            "There are generally two types of circular linked lists:",
            "Representation of Circular singly linked list",
            "Representation of circular doubly linked list",
            "Note: We will be using the singly circular linked list to represent the working of the circular linked list.",
            "Circular linked lists are similar to single Linked Lists with the exception of connecting the last node to the first node.",
            "Node representation of a Circular Linked List:",
            "Example of Circular singly linked list:",
            "Example of  circular linked list",
            "The above  Circular singly linked list can be represented as:",
            "Explanation: In the above program one, two, and three are the node with values 3, 5, and 9 respectively which are connected in a circular manner as:",
            "We can do some operations on the circular linked list similar to the singly linked list which are:",
            "A node can be added in three ways:",
            "1) Insertion at the beginning of the list: To insert a node at the beginning of the list, follow these steps: ",
            "Circular linked list before insertion",
            "And then, ",
            "Circular linked list after insertion",
            "2) Insertion at the end of the list: To insert a node at the end of the list, follow these steps: ",
            "Before insertion,",
            "Circular linked list before insertion of node at the end",
            "After insertion,",
            "Circular linked list after insertion of node at the end",
            "3) Insertion in between the nodes: To insert a node in between the two nodes, follow these steps: ",
            "Suppose 12 needs to be inserted after the node has the value 10,",
            "Circular linked list before insertion",
            "After searching and insertion,",
            "Circular linked list after  insertion",
            "1) Delete the node only if it is the only node in the circular linked list:",
            "2) Deletion of the last node:",
            "3) Delete any node from the circular linked list: We will be given a node and our task is to delete that node from the circular linked list.",
            "Algorithm:Case 1: List is empty. ",
            "Case 2:List is not empty  ",
            "Below is the implementation for the above approach:",
            "Time Complexity: O(N), Worst case occurs when the element to be deleted is the last element and we need to move through the whole list.Auxiliary Space: O(1), As constant extra space is used.",
            "Next Posts: Circular Linked List | Set 2 (Traversal) Circular Singly Linked List | Insertion Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:42.430821",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Counting Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks",
        "rating": 874,
        "pageId": "7aefce40-8ed1-46a7-8942-b0859da6cabf",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/counting-sort/?ref=outind",
        "content": [
            "Counting Sort is a non-comparison-based sorting algorithm that works well when there is limited range of input values. It is particularly efficient when the range of input values is small compared to the number of elements to be sorted. The basic idea behind Counting Sort is to count the frequency of each distinct element in the input array and use that information to place the elements in their correct sorted positions.",
            "Step1 :",
            "Step 2:",
            "Step 3:",
            "Step 4:",
            "Step 5:",
            "Step 6: For i = 6,",
            "Update outputArray[ countArray[ inputArray[6] ] \u2013 1] = inputArray[6]Also, update countArray[ inputArray[6] ]  = countArray[ inputArray[6] ]- \u2013",
            "Step 7: For i = 5,",
            "Update outputArray[ countArray[ inputArray[5] ] \u2013 1] = inputArray[5]Also, update countArray[ inputArray[5] ]  = countArray[ inputArray[5] ]- \u2013",
            "Step 8: For i = 4,",
            "Update outputArray[ countArray[ inputArray[4] ] \u2013 1] = inputArray[4]Also, update countArray[ inputArray[4] ]  = countArray[ inputArray[4] ]- \u2013",
            "Step 9: For i = 3,",
            "Update outputArray[ countArray[ inputArray[3] ] \u2013 1] = inputArray[3]Also, update countArray[ inputArray[3] ]  = countArray[ inputArray[3] ]- \u2013",
            "Step 10: For i = 2,",
            "Update outputArray[ countArray[ inputArray[2] ] \u2013 1] = inputArray[2]Also, update countArray[ inputArray[2] ]  = countArray[ inputArray[2] ]- \u2013",
            "Step 11: For i = 1,",
            "Update outputArray[ countArray[ inputArray[1] ] \u2013 1] = inputArray[1]Also, update countArray[ inputArray[1] ]  = countArray[ inputArray[1] ]- \u2013",
            "Step 12: For i = 0,",
            "Update outputArray[ countArray[ inputArray[0] ] \u2013 1] = inputArray[0]Also, update countArray[ inputArray[0] ]  = countArray[ inputArray[0] ]- \u2013",
            "Below is the implementation of the above algorithm:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:18.571793",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Arrays - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 853,
        "pageId": "2da75961-42cc-48df-8d8d-753b6345e4da",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "An array is a collection of items of the same variable type that are stored at contiguous memory locations. It\u2019s one of the most popular and simple data structures and is often used to implement other data structures. Each item in an array is indexed starting with 0.",
            "The dream of every programmer is to become not just a good, but also a great programmer. We all want to achieve our goals and to achieve our goals, we must have a great plan with us. In this context, we have decided to provide a complete guide for Arrays interview preparation, which will help you to tackle the problems that are mostly asked in the interview, such as What is an Array, What is Array in C language, How do you initialize an Array in C, How to sort an Array, etc. We have also covered the topics such as Top Theoretical interview questions and Top interview coding questions in this complete guide for Array interview preparation.",
            "Complete guide for Arrays interview preparation",
            "We can directly access an array element by using its index value.",
            "The representation of an array can be defined by its declaration. A declaration means allocating memory for an array of a given size.",
            "Array",
            "Arrays can be declared in various ways in different languages. For better illustration, below are some language-specific array declarations.",
            "Array declaration",
            "However, the above declaration is static or compile-time memory allocation, which means that the array element\u2019s memory is allocated when a program is compiled. Here only a fixed size (i,e. the size that is mentioned in square brackets []) of memory will be allocated for storage, but don\u2019t you think it will not be the same situation as we know the size of the array every time, there might be a case where we don\u2019t know the size of the array. If we declare a larger size and store a lesser number of elements will result in a wastage of memory or either be a case where we declare a lesser size then we won\u2019t get enough memory to store the rest of the elements. In such cases, static memory allocation is not preferred.",
            "The answer is Yes. It is possible to allocate memory dynamically. So, dynamic memory allocation is the process of assigning the memory space during the execution time or the run time.",
            "Below are the languages that support dynamic memory allocation:",
            "Assume there is a class of five students and if we have to keep records of their marks in examination then, we can do this by declaring five variables individual and keeping track of records but what if the number of students becomes very large, it would be challenging to manipulate and maintain the data.",
            "What it means is that, we can use normal variables (v1, v2, v3, ..) when we have a small number of objects. But if we want to store a large number of instances, it becomes difficult to manage them with normal variables. The idea of an array is to represent many instances in one variable..",
            "Need for Array",
            "There are majorly two types of arrays:",
            "1D array",
            "2D array",
            "3D array",
            "An array is a collection of items of the same data type stored at contiguous memory locations. Ex. int arr[5] = {1,2,3,4,5};",
            "Arrays store elements of the same type, they are classified as homogeneous data structures. They can store numbers, strings, characters, boolean values (true and false), objects, and so on.",
            " An array is a linear data structure that stores similar elements in contiguous memory locations.",
            "There are majorly two types of arrays:",
            "An array is a collection of items of the same data type stored at contiguous memory locations or says the elements are stored one after another in memory. An array uses an index system starting at 0 and going to (n-1), where n is its size.",
            "The structure can contain variables of different types but an array only contains variables of the same type. ",
            "An array is a collection of items of the same data type. That means, in an integer array only integer values can be stored, while in a float array only floating values and character array can have only characters. Thus, no array can have values of two data types.",
            "There are multiple advantages of array data structure and some of them are:",
            "An array is used when several variables of the same type need to be used, and it can be defined as a sequence of objects of the same type.  ",
            "A multi-dimensional array can be termed as an array of arrays that stores homogeneous data in tabular form. Data in Multidimensional Arrays are stored in row-major order. ",
            "After the discussion, we concluded that arrays are a simple method of accessing elements of the same type by grouping them and we can find the elements efficiently by their indexes and can perform different operations using them. Thus, they are more efficient when it comes to memory allocation and should be used in all modern programming languages. So, this becomes a favorite topic for the perspective of the interview and most of the companies generally asked about the problems on the array. For all these reasons, we must have a good knowledge of it.",
            "Related articles:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:23.709382400",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Binary Search Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 833,
        "pageId": "65b054d3-103d-4dca-a70b-2c9597363d3f",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-binary-search-tree-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A Binary Search Tree (BST) is a special type of binary tree in which the left child of a node has a value less than the node\u2019s value and the right child has a value greater than the node\u2019s value. This property is called the BST property and it makes it possible to efficiently search, insert, and delete elements in the tree.",
            "The root of a BST is the node that has the smallest value in the left subtree and the largest value in the right subtree. Each left subtree is a BST with nodes that have smaller values than the root and each right subtree is a BST with nodes that have larger values than the root.",
            "Binary Search Tree is a node-based binary tree data structure that has the following properties: ",
            "Handling approach for Duplicate values in the Binary Search tree:",
            "Below are the various operations that can be performed on a BST:",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Different scenarios for deleting the node:",
            "Time Complexity: O(log N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(log N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) ",
            "Time Complexity: O(N), where N is the number of nodes of the BST Auxiliary Space: O(1) "
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:19.303442100",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Matrix or Grid | Multi-Dimensional Array Tutorial - GeeksforGeeks",
        "rating": 800,
        "pageId": "2e69fd26-0db8-4286-a1d8-cae9e364b910",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-matrix-or-grid-data-structure-and-algorithms-tutorial/?ref=outind",
        "content": [
            "A matrix is a two-dimensional array that consists of rows and columns. It is an arrangement of elements in horizontal or vertical lines of entries.",
            "Introduction to Matrix or Grid \u2013 Data Structure and Algorithms Tutorials",
            "The syntax of declaring a Matrix or two-dimensional array is very much similar to that of a one-dimensional array, given as follows.",
            "However, It produces a data structure that looks like the following:",
            "Representation of matrix",
            "As you can see from the above image, the elements are organized in rows and columns. As shown in the above image the cell x[0][0] is the first element of the first row and first column. The value in the first square bracket represents the row number and the value inside the second square bracket represents the column number. (i.e, x[row][column]).",
            "There are two methods to initialize two-dimensional arrays.",
            "Method 1",
            "int arr[4][3]={1, 2, 3, 4, 5, 6, 20, 80, 90, 100, 110, 120};",
            "Method 2",
            "int arr[4][3]={{1, 2, 3}, {4, 5, 6}, {20, 80, 90}, {100, 110, 120}};",
            "Here are two methods of initialization of an element during declaration. Here, the second method is preferred because the second method is more readable and understandable so that you can visualize that arr[][] comprises four rows and three columns.",
            "Like one-dimensional arrays, matrices can be accessed randomly by using their indices to access the individual elements. A cell has two indices, one for its row number, and the other for its column number. We can use X[i][j] to access the element which is at the ith row and jth column of the matrix.",
            "Matrix",
            "The syntax for access element from the matrix which is at the ith row and jth column:",
            "Printing elements of a matrix or two-dimensional array can be done using two \u201cfor\u201d loops.",
            "Given a matrix mat[][] of size N x M, where every row and column is sorted in increasing order, and a number X is given. The task is to find whether element X is present in the matrix or not.",
            "Examples:",
            "Input : mat[][] = { {1, 5, 9},                    {14, 20, 21},                    {30, 34, 43} }       x = 14Output : YES",
            "Input : mat[][] = { {1, 5, 9, 11},                    {14, 20, 21, 26},                    {30, 34, 43, 50} }       x = 42Output : NO",
            "Solution:",
            "There are a lot of ways to solve this problem but let\u2019s discuss the idea of a very naive or brute-force approach here.",
            "A Simple Solution is to one by one compare x with every element of the matrix. If matches, then return true. If we reach the end then return false. The time complexity of this solution is O(n x m).",
            "Below is the implementation of the above idea:",
            "Time Complexity: O(M*N), where M and N are the numbers of rows and columns respectively.Auxiliary Space: O(1)",
            "Given a 2D square matrix, print the Principal and Secondary diagonals.",
            "Examples :",
            "Input: 1 2 3 44 3 2 17 8 9 66 5 4 3Output:Principal Diagonal: 1, 3, 9, 3Secondary Diagonal: 4, 2, 8, 6",
            "Input:1 1 11 1 11 1 1Output:Principal Diagonal: 1, 1, 1Secondary Diagonal: 1, 1, 1",
            "Solution:",
            "The primary diagonal is formed by the elements A00, A11, A22, A33.Condition for Principal Diagonal: The row-column condition is row = column.",
            "The secondary diagonal is formed by the elements A03, A12, A21, A30. Condition for Secondary Diagonal: The row-column condition is row = numberOfRows \u2013 column -1.",
            "Time Complexity: O(n2), As there is a nested loop involved so the time complexity is squared.Auxiliary Space: O(1).  ",
            "Given a n x n matrix. The problem is to sort the given matrix in strict order. Here strict order means that the matrix is sorted in a way such that all elements in a row are sorted in increasing order and for row \u2018i\u2019, where 1 <= i <= n-1, the first element of row \u2018i\u2019 is greater than or equal to the last element of row \u2018i-1\u2019.",
            "Examples:",
            "Input : mat[][] = { {5, 4, 7},                          {1, 3, 8},                         {2, 9, 6} }Output : 1 2 3             4 5 6             7 8 9",
            "Solution: ",
            "The idea to solve this proble is Create a temp[] array of size n^2. Starting with the first row one by one copy the elements of the given matrix into temp[]. Sort temp[]. Now one by one copy the elements of temp[] back to the given matrix.",
            "Below is the implementation:",
            "Time Complexity: O(n2log2n). Auxiliary Space: O(n2), since n * n extra space has been taken.",
            "Given a square matrix, the task is that turn it by 180 degrees in an anti-clockwise direction without using any extra space.",
            "Examples :",
            "Input :  1  2  3        4  5  6        7  8  9Output : 9 8 7         6 5 4         3 2 1",
            "Input :  1 2 3 4         5 6 7 8         9 0 1 2         3 4 5 6 Output : 6 5 4 3         2 1 0 9         8 7 6 5         4 3 2 1",
            "Solution:",
            "There are four steps that are required to solve this problem:1- Find the transpose of a matrix. 2- Reverse columns of the transpose. 3- Find the transpose of a matrix. 4- Reverse columns of the transpose",
            "Illustration:",
            "Let the given matrix be1  2  3  45  6  7  89  10 11 1213 14 15 16",
            "First we find transpose.1 5 9 132 6 10 143 7 11 154 8 12 16",
            "Then we reverse elements of every column.4 8 12 163 7 11 152 6 10 141 5  9 13",
            "then transpose again 4 3 2 1 8 7 6 5 12 11 10 916 15 14 13",
            "Then we reverse elements of every column again16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1",
            "Below is the implementation:",
            "Time complexity: O(R*C) Auxiliary Space: O(1)",
            "Given a matrix mat[][] having n rows and m columns. We need to find unique elements in the matrix i.e, those elements not repeated in the matrix or those whose frequency is 1.",
            "Examples:",
            "Input :  20  15  30  2        2   3   5   30        6   7   6   8Output : 3  20  5  7  8  15",
            "Input :  1  2  3          5  6  2        1  3  5        6  2  2Output : No unique element in the matrix",
            "Solution:",
            "The idea is to use hashing and traverse through all the elements of the matrix, If an element is present in the dictionary, then increment its count. Otherwise insert an element with value = 1. ",
            "Below is the implementation:",
            "Time Complexity: O(m*n) where m is the number of rows & n is the number of columns.Auxiliary Space: O(max(matrix)). ",
            "Related Article:"
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:23.214471900",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "Introduction to Binary Tree - Data Structure and Algorithm Tutorials - GeeksforGeeks",
        "rating": 743,
        "pageId": "49c7c123-72b9-4722-a891-899e6b212278",
        "pageName": "geeksforgeeks.org",
        "url": "https://www.geeksforgeeks.org/introduction-to-binary-tree-data-structure-and-algorithm-tutorials/?ref=outind",
        "content": [
            "A binary tree is a tree data structure in which each node can have at most two children, which are referred to as the left child and the right child. ",
            "The topmost node in a binary tree is called the root, and the bottom-most nodes are called leaves. A binary tree can be visualized as a hierarchical structure with the root at the top and the leaves at the bottom.",
            "Binary trees have many applications in computer science, including data storage and retrieval, expression evaluation, network routing, and game AI. They can also be used to implement various algorithms such as searching, sorting, and graph algorithms.",
            "Each node in the tree contains the following:",
            "Binary Tree",
            "In C, we can represent a tree node using structures. In other languages, we can use classes as part of their OOP feature. Below is an example of a tree node with integer data.",
            "Tree Traversal algorithms can be classified broadly into two categories:",
            "Let us traverse the following tree with all four traversal methods:",
            "Binary Tree",
            "Pre-order Traversal of the above tree: 1-2-4-5-3-6-7In-order Traversal of the above tree: 4-2-5-1-6-3-7Post-order Traversal of the above tree: 4-5-2-6-7-3-1Level-order Traversal of the above tree: 1-2-3-4-5-6-7",
            "Let us create a simple tree with 4 nodes. The created tree would be as follows. ",
            "Binary Tree",
            "Below is the Implementation of the binary tree:",
            "Tree is a hierarchical data structure. Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.",
            "Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above."
        ]
    },
    {
        "lastTimeCrawled": "2024-01-03T08:57:18.119271600",
        "images": [],
        "favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "pageTitle": "GeeksforGeeks | A computer science portal for geeks",
        "rating": 503,
        "pageId": "8dc124a2-f431-407f-ab18-178c26a3c155",
        "pageName": "GeeksforGeeks | A computer science portal for geeks",
        "url": "https://www.geeksforgeeks.org/",
        "content": []
    }
]